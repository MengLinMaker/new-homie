/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    '/access-control/assignments/search': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Debug permissions.
         * @description Returns the result of the search through access-control role assignments.
         *
         *     You need to have a permission with action `teams.roles:read` on scope `teams:*`
         *     and a permission with action `users.roles:read` on scope `users:*`.
         */
        post: operations['searchResult']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/access-control/roles': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get all roles.
         * @description Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.
         *
         *     You need to have a permission with action `roles:read` and scope `roles:*`.
         *
         *     The `delegatable` flag reduces the set of roles to only those for which the signed-in user has permissions to assign.
         */
        get: operations['listRoles']
        put?: never
        /**
         * Create a new custom role.
         * @description Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.
         *
         *     You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
         *     For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
         */
        post: operations['createRole']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/access-control/roles/{roleUID}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get a role.
         * @description Get a role for the given UID.
         *
         *     You need to have a permission with action `roles:read` and scope `roles:*`.
         */
        get: operations['getRole']
        /**
         * Update a custom role.
         * @description You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
         */
        put: operations['updateRole']
        post?: never
        /**
         * Delete a custom role.
         * @description Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.
         *
         *     You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
         */
        delete: operations['deleteRole']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/access-control/roles/{roleUID}/assignments': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get role assignments.
         * @description Get role assignments for the role with the given UID.
         *     Does not include role assignments mapped through group attribute sync.
         *
         *     You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
         */
        get: operations['getRoleAssignments']
        /**
         * Set role assignments.
         * @description Set role assignments for the role with the given UID.
         *
         *     You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
         */
        put: operations['setRoleAssignments']
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/access-control/status': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get status.
         * @description Returns an indicator to check if fine-grained access control is enabled or not.
         *
         *     You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
         */
        get: operations['getAccessControlStatus']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/access-control/teams/roles/search': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * List roles assigned to multiple teams.
         * @description Lists the roles that have been directly assigned to the given teams.
         *
         *     You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
         */
        post: operations['listTeamsRoles']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/access-control/teams/{teamId}/roles': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get team roles.
         * @description You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
         */
        get: operations['listTeamRoles']
        /**
         * Update team role.
         * @description You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
         */
        put: operations['setTeamRoles']
        /**
         * Add team role.
         * @description You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
         */
        post: operations['addTeamRole']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/access-control/teams/{teamId}/roles/{roleUID}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        /**
         * Remove team role.
         * @description You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
         */
        delete: operations['removeTeamRole']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/access-control/users/roles/search': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * List roles assigned to multiple users.
         * @description Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.
         *
         *     You need to have a permission with action `users.roles:read` and scope `users:id:*`.
         */
        post: operations['listUsersRoles']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/access-control/users/{userId}/roles': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * List roles assigned to a user.
         * @description Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.
         *
         *     You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
         */
        get: operations['listUserRoles']
        /**
         * Set user role assignments.
         * @description Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user.
         *     Roles mapped through group attribute sync are not impacted.
         *     If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.
         *
         *     You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
         */
        put: operations['setUserRoles']
        /**
         * Add a user role assignment.
         * @description Assign a role to a specific user. For bulk updates consider Set user role assignments.
         *
         *     You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
         */
        post: operations['addUserRole']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/access-control/users/{userId}/roles/{roleUID}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        /**
         * Remove a user role assignment.
         * @description Revoke a role from a user. For bulk updates consider Set user role assignments.
         *
         *     You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
         */
        delete: operations['removeUserRole']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/access-control/{resource}/description': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get a description of a resource's access control properties. */
        get: operations['getResourceDescription']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/access-control/{resource}/{resourceID}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get permissions for a resource. */
        get: operations['getResourcePermissions']
        put?: never
        /**
         * Set resource permissions.
         * @description Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to one or many
         *     assignment types. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`.
         *     Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         */
        post: operations['setResourcePermissions']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/access-control/{resource}/{resourceID}/builtInRoles/{builtInRole}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Set resource permissions for a built-in role.
         * @description Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a built-in role.
         *     Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`.
         *     Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         */
        post: operations['setResourcePermissionsForBuiltInRole']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/access-control/{resource}/{resourceID}/teams/{teamID}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Set resource permissions for a team.
         * @description Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a team.
         *     Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`.
         *     Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         */
        post: operations['setResourcePermissionsForTeam']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/access-control/{resource}/{resourceID}/users/{userID}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Set resource permissions for a user.
         * @description Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a user or a service account.
         *     Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`.
         *     Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         */
        post: operations['setResourcePermissionsForUser']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/ldap-sync-status': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Returns the current state of the LDAP background sync integration.
         * @description You need to have a permission with action `ldap.status:read`.
         */
        get: operations['getSyncStatus']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/ldap/reload': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Reloads the LDAP configuration.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.config:reload`.
         */
        post: operations['reloadLDAPCfg']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/ldap/status': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Attempts to connect to all the configured LDAP servers and returns information on whenever they're available or not.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.status:read`.
         */
        get: operations['getLDAPStatus']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/ldap/sync/{user_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Enables a single Grafana user to be synchronized against LDAP.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:sync`.
         */
        post: operations['postSyncUserWithLDAP']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/ldap/{user_name}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Finds an user based on a username in LDAP. This helps illustrate how would the particular user be mapped in Grafana when synced.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:read`.
         */
        get: operations['getUserFromLDAP']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/provisioning/access-control/reload': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** You need to have a permission with action `provisioning:reload` with scope `provisioners:accesscontrol`. */
        post: operations['adminProvisioningReloadAccessControl']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/provisioning/dashboards/reload': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Reload dashboard provisioning configurations.
         * @description Reloads the provisioning config files for dashboards again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning.
         *     If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:dashboards`.
         */
        post: operations['adminProvisioningReloadDashboards']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/provisioning/datasources/reload': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Reload datasource provisioning configurations.
         * @description Reloads the provisioning config files for datasources again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning.
         *     If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:datasources`.
         */
        post: operations['adminProvisioningReloadDatasources']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/provisioning/plugins/reload': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Reload plugin provisioning configurations.
         * @description Reloads the provisioning config files for plugins again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning.
         *     If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:plugin`.
         */
        post: operations['adminProvisioningReloadPlugins']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/settings': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Fetch settings.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `settings:read` and scopes: `settings:*`, `settings:auth.saml:` and `settings:auth.saml:enabled` (property level).
         */
        get: operations['adminGetSettings']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/stats': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Fetch Grafana Stats.
         * @description Only works with Basic Authentication (username and password). See introduction for an explanation.
         *     If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `server:stats:read`.
         */
        get: operations['adminGetStats']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/users': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Create new user.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:create`.
         *     Note that OrgId is an optional parameter that can be used to assign a new user to a different organization when `auto_assign_org` is set to `true`.
         */
        post: operations['adminCreateUser']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/users/{user_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        /**
         * Delete global User.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:delete` and scope `global.users:*`.
         */
        delete: operations['adminDeleteUser']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/users/{user_id}/auth-tokens': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Return a list of all auth tokens (devices) that the user currently have logged in from.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:list` and scope `global.users:*`.
         */
        get: operations['adminGetUserAuthTokens']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/users/{user_id}/disable': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Disable user.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:disable` and scope `global.users:1` (userIDScope).
         */
        post: operations['adminDisableUser']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/users/{user_id}/enable': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Enable user.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:enable` and scope `global.users:1` (userIDScope).
         */
        post: operations['adminEnableUser']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/users/{user_id}/logout': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Logout user revokes all auth tokens (devices) for the user. User of issued auth tokens (devices) will no longer be logged in and will be required to authenticate again upon next activity.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.logout` and scope `global.users:*`.
         */
        post: operations['adminLogoutUser']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/users/{user_id}/password': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        /**
         * Set password for user.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.password:update` and scope `global.users:*`.
         */
        put: operations['adminUpdateUserPassword']
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/users/{user_id}/permissions': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        /**
         * Set permissions for user.
         * @description Only works with Basic Authentication (username and password). See introduction for an explanation.
         *     If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.permissions:update` and scope `global.users:*`.
         */
        put: operations['adminUpdateUserPermissions']
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/users/{user_id}/quotas': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Fetch user quota.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:list` and scope `global.users:1` (userIDScope).
         */
        get: operations['getUserQuota']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/users/{user_id}/quotas/{quota_target}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        /**
         * Update user quota.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:update` and scope `global.users:1` (userIDScope).
         */
        put: operations['updateUserQuota']
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/admin/users/{user_id}/revoke-auth-token': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Revoke auth token for user.
         * @description Revokes the given auth token (device) for the user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity.
         *     If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:update` and scope `global.users:*`.
         */
        post: operations['adminRevokeUserAuthToken']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/annotations': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Find Annotations.
         * @description Starting in Grafana v6.4 regions annotations are now returned in one entity that now includes the timeEnd property.
         */
        get: operations['getAnnotations']
        put?: never
        /**
         * Create Annotation.
         * @description Creates an annotation in the Grafana database. The dashboardId and panelId fields are optional. If they are not specified then an organization annotation is created and can be queried in any dashboard that adds the Grafana annotations data source. When creating a region annotation include the timeEnd property.
         *     The format for `time` and `timeEnd` should be epoch numbers in millisecond resolution.
         *     The response for this HTTP request is slightly different in versions prior to v6.4. In prior versions you would also get an endId if you where creating a region. But in 6.4 regions are represented using a single event with time and timeEnd properties.
         */
        post: operations['postAnnotation']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/annotations/graphite': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Create Annotation in Graphite format.
         * @description Creates an annotation by using Graphite-compatible event format. The `when` and `data` fields are optional. If `when` is not specified then the current time will be used as annotation’s timestamp. The `tags` field can also be in prior to Graphite `0.10.0` format (string with multiple tags being separated by a space).
         */
        post: operations['postGraphiteAnnotation']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/annotations/mass-delete': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** Delete multiple annotations. */
        post: operations['massDeleteAnnotations']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/annotations/tags': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Find Annotations Tags.
         * @description Find all the event tags created in the annotations.
         */
        get: operations['getAnnotationTags']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/annotations/{annotation_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get Annotation by ID. */
        get: operations['getAnnotationByID']
        /**
         * Update Annotation.
         * @description Updates all properties of an annotation that matches the specified id. To only update certain property, consider using the Patch Annotation operation.
         */
        put: operations['updateAnnotation']
        post?: never
        /**
         * Delete Annotation By ID.
         * @description Deletes the annotation that matches the specified ID.
         */
        delete: operations['deleteAnnotationByID']
        options?: never
        head?: never
        /**
         * Patch Annotation.
         * @description Updates one or more properties of an annotation that matches the specified ID.
         *     This operation currently supports updating of the `text`, `tags`, `time` and `timeEnd` properties.
         *     This is available in Grafana 6.0.0-beta2 and above.
         */
        patch: operations['patchAnnotation']
        trace?: never
    }
    '/auth/keys': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get auth keys.
         * @description Will return auth keys.
         *
         *     Deprecated: true.
         *
         *     Deprecated. Please use GET /api/serviceaccounts and GET /api/serviceaccounts/{id}/tokens instead
         *     see https://grafana.com/docs/grafana/next/administration/service-accounts/migrate-api-keys/.
         */
        get: operations['getAPIkeys']
        put?: never
        /**
         * Creates an API key.
         * @deprecated
         * @description Will return details of the created API key.
         */
        post: operations['addAPIkey']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/auth/keys/{id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        /**
         * Delete API key.
         * @deprecated
         * @description Deletes an API key.
         *     Deprecated. See: https://grafana.com/docs/grafana/next/administration/service-accounts/migrate-api-keys/.
         */
        delete: operations['deleteAPIkey']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/cloudmigration/migration': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get a list of all cloud migration sessions that have been created. */
        get: operations['getSessionList']
        put?: never
        /** Create a migration session. */
        post: operations['createSession']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/cloudmigration/migration/{uid}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get a cloud migration session by its uid. */
        get: operations['getSession']
        put?: never
        post?: never
        /** Delete a migration session by its uid. */
        delete: operations['deleteSession']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/cloudmigration/migration/{uid}/snapshot': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Trigger the creation of an instance snapshot associated with the provided session.
         * @description If the snapshot initialization is successful, the snapshot uid is returned.
         */
        post: operations['createSnapshot']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/cloudmigration/migration/{uid}/snapshot/{snapshotUid}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get metadata about a snapshot, including where it is in its processing and final results. */
        get: operations['getSnapshot']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/cloudmigration/migration/{uid}/snapshot/{snapshotUid}/cancel': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Cancel a snapshot, wherever it is in its processing chain.
         * @description TODO: Implement
         */
        post: operations['cancelSnapshot']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/cloudmigration/migration/{uid}/snapshot/{snapshotUid}/upload': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** Upload a snapshot to the Grafana Migration Service for processing. */
        post: operations['uploadSnapshot']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/cloudmigration/migration/{uid}/snapshots': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get a list of snapshots for a session. */
        get: operations['getShapshotList']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/cloudmigration/resources/dependencies': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get the resource dependencies graph for the current set of migratable resources. */
        get: operations['getResourceDependencies']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/cloudmigration/token': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Fetch the cloud migration token if it exists. */
        get: operations['getCloudMigrationToken']
        put?: never
        /** Create gcom access token. */
        post: operations['createCloudMigrationToken']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/cloudmigration/token/{uid}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        /** Deletes a cloud migration token. */
        delete: operations['deleteCloudMigrationToken']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboard/snapshots': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** List snapshots. */
        get: operations['searchDashboardSnapshots']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/calculate-diff': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** Perform diff on two dashboards. */
        post: operations['calculateDashboardDiff']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/db': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Create / Update dashboard
         * @description Creates a new dashboard or updates an existing dashboard.
         *     Note: This endpoint is not intended for creating folders, use `POST /api/folders` for that.
         */
        post: operations['postDashboard']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/home': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get home dashboard. */
        get: operations['getHomeDashboard']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/id/{DashboardID}/permissions': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Gets all existing permissions for the given dashboard.
         * @deprecated
         * @description Please refer to [updated API](#/dashboard_permissions/getDashboardPermissionsListByUID) instead
         */
        get: operations['getDashboardPermissionsListByID']
        put?: never
        /**
         * Updates permissions for a dashboard.
         * @deprecated
         * @description Please refer to [updated API](#/dashboard_permissions/updateDashboardPermissionsByUID) instead
         *
         *     This operation will remove existing permissions if they’re not included in the request.
         */
        post: operations['updateDashboardPermissionsByID']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/id/{DashboardID}/restore': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Restore a dashboard to a given dashboard version.
         * @deprecated
         * @description Please refer to [updated API](#/dashboard_versions/restoreDashboardVersionByUID) instead
         */
        post: operations['restoreDashboardVersionByID']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/id/{DashboardID}/versions': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Gets all existing versions for the dashboard.
         * @deprecated
         * @description Please refer to [updated API](#/dashboard_versions/getDashboardVersionsByUID) instead
         */
        get: operations['getDashboardVersionsByID']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/id/{DashboardID}/versions/{DashboardVersionID}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get a specific dashboard version.
         * @deprecated
         * @description Please refer to [updated API](#/dashboard_versions/getDashboardVersionByUID) instead
         */
        get: operations['getDashboardVersionByID']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/import': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** Import dashboard. */
        post: operations['importDashboard']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/public-dashboards': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description Get list of public dashboards */
        get: operations['listPublicDashboards']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/tags': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get all dashboards tags of an organisation. */
        get: operations['getDashboardTags']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/uid/{dashboardUid}/public-dashboards': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description Get public dashboard by dashboardUid */
        get: operations['getPublicDashboard']
        put?: never
        /** @description Create public dashboard for a dashboard */
        post: operations['createPublicDashboard']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/uid/{dashboardUid}/public-dashboards/{uid}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        /** @description Delete public dashboard for a dashboard */
        delete: operations['deletePublicDashboard']
        options?: never
        head?: never
        /** @description Update public dashboard for a dashboard */
        patch: operations['updatePublicDashboard']
        trace?: never
    }
    '/dashboards/uid/{uid}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get dashboard by uid.
         * @description Will return the dashboard given the dashboard unique identifier (uid).
         */
        get: operations['getDashboardByUID']
        put?: never
        post?: never
        /**
         * Delete dashboard by uid.
         * @description Will delete the dashboard given the specified unique identifier (uid).
         */
        delete: operations['deleteDashboardByUID']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/uid/{uid}/permissions': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Gets all existing permissions for the given dashboard. */
        get: operations['getDashboardPermissionsListByUID']
        put?: never
        /**
         * Updates permissions for a dashboard.
         * @description This operation will remove existing permissions if they’re not included in the request.
         */
        post: operations['updateDashboardPermissionsByUID']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/uid/{uid}/restore': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** Restore a dashboard to a given dashboard version using UID. */
        post: operations['restoreDashboardVersionByUID']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/uid/{uid}/versions': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Gets all existing versions for the dashboard using UID. */
        get: operations['getDashboardVersionsByUID']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/dashboards/uid/{uid}/versions/{DashboardVersionID}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get a specific dashboard version using UID. */
        get: operations['getDashboardVersionByUID']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get all data sources.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `datasources:read` and scope: `datasources:*`.
         */
        get: operations['getDataSources']
        put?: never
        /**
         * Create a data source.
         * @description By defining `password` and `basicAuthPassword` under secureJsonData property
         *     Grafana encrypts them securely as an encrypted blob in the database.
         *     The response then lists the encrypted fields under secureJsonFields.
         *
         *     If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `datasources:create`
         */
        post: operations['addDataSource']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/correlations': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Gets all correlations. */
        get: operations['getCorrelations']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/id/{name}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get data source Id by Name.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
         */
        get: operations['getDataSourceIdByName']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/name/{name}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get a single data source by Name.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
         */
        get: operations['getDataSourceByName']
        put?: never
        post?: never
        /**
         * Delete an existing data source by name.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
         */
        delete: operations['deleteDataSourceByName']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/proxy/uid/{uid}/{datasource_proxy_route}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Data source proxy GET calls.
         * @description Proxies all calls to the actual data source.
         */
        get: operations['datasourceProxyGETByUIDcalls']
        put?: never
        /**
         * Data source proxy POST calls.
         * @description Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined
         */
        post: operations['datasourceProxyPOSTByUIDcalls']
        /**
         * Data source proxy DELETE calls.
         * @description Proxies all calls to the actual data source.
         */
        delete: operations['datasourceProxyDELETEByUIDcalls']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/proxy/{id}/{datasource_proxy_route}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Data source proxy GET calls.
         * @deprecated
         * @description Proxies all calls to the actual data source.
         *
         *     Please refer to [updated API](#/datasources/datasourceProxyGETByUIDcalls) instead
         */
        get: operations['datasourceProxyGETcalls']
        put?: never
        /**
         * Data source proxy POST calls.
         * @deprecated
         * @description Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined
         *
         *     Please refer to [updated API](#/datasources/datasourceProxyPOSTByUIDcalls) instead
         */
        post: operations['datasourceProxyPOSTcalls']
        /**
         * Data source proxy DELETE calls.
         * @deprecated
         * @description Proxies all calls to the actual data source.
         *
         *     Please refer to [updated API](#/datasources/datasourceProxyDELETEByUIDcalls) instead
         */
        delete: operations['datasourceProxyDELETEcalls']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/uid/{sourceUID}/correlations': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Gets all correlations originating from the given data source. */
        get: operations['getCorrelationsBySourceUID']
        put?: never
        /** Add correlation. */
        post: operations['createCorrelation']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/uid/{sourceUID}/correlations/{correlationUID}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Gets a correlation. */
        get: operations['getCorrelation']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        /** Updates a correlation. */
        patch: operations['updateCorrelation']
        trace?: never
    }
    '/datasources/uid/{uid}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get a single data source by UID.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
         */
        get: operations['getDataSourceByUID']
        /**
         * Update an existing data source.
         * @description Similar to creating a data source, `password` and `basicAuthPassword` should be defined under
         *     secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the
         *     encrypted fields are listed under secureJsonFields section in the response.
         *
         *     If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:1` (single data source).
         */
        put: operations['updateDataSourceByUID']
        post?: never
        /**
         * Delete an existing data source by UID.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
         */
        delete: operations['deleteDataSourceByUID']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/uid/{uid}/correlations/{correlationUID}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        /** Delete a correlation. */
        delete: operations['deleteCorrelation']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/uid/{uid}/health': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Sends a health check request to the plugin datasource identified by the UID. */
        get: operations['checkDatasourceHealthWithUID']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/uid/{uid}/lbac/teams': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Retrieves LBAC rules for a team. */
        get: operations['getTeamLBACRulesApi']
        /** Updates LBAC rules for a team. */
        put: operations['updateTeamLBACRulesApi']
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/uid/{uid}/resources/{datasource_proxy_route}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Fetch data source resources. */
        get: operations['callDatasourceResourceWithUID']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/{dataSourceUID}/cache': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description get cache config for a single data source */
        get: operations['getDataSourceCacheConfig']
        put?: never
        /** @description set cache config for a single data source */
        post: operations['setDataSourceCacheConfig']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/{dataSourceUID}/cache/clean': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** @description clean cache for a single data source */
        post: operations['cleanDataSourceCache']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/{dataSourceUID}/cache/disable': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** @description disable cache for a single data source */
        post: operations['disableDataSourceCache']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/{dataSourceUID}/cache/enable': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** @description enable cache for a single data source */
        post: operations['enableDataSourceCache']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/{id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get a single data source by Id.
         * @deprecated
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).
         *
         *     Please refer to [updated API](#/datasources/getDataSourceByUID) instead
         */
        get: operations['getDataSourceByID']
        /**
         * Update an existing data source by its sequential ID.
         * @deprecated
         * @description Similar to creating a data source, `password` and `basicAuthPassword` should be defined under
         *     secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the
         *     encrypted fields are listed under secureJsonFields section in the response.
         *
         *     If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).
         *
         *     Please refer to [updated API](#/datasources/updateDataSourceByUID) instead
         */
        put: operations['updateDataSourceByID']
        post?: never
        /**
         * Delete an existing data source by id.
         * @deprecated
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).
         *
         *     Please refer to [updated API](#/datasources/deleteDataSourceByUID) instead
         */
        delete: operations['deleteDataSourceByID']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/{id}/health': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Sends a health check request to the plugin datasource identified by the ID.
         * @deprecated
         * @description Please refer to [updated API](#/datasources/checkDatasourceHealthWithUID) instead
         */
        get: operations['checkDatasourceHealthByID']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/datasources/{id}/resources/{datasource_proxy_route}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Fetch data source resources by Id.
         * @deprecated
         * @description Please refer to [updated API](#/datasources/callDatasourceResourceWithUID) instead
         */
        get: operations['callDatasourceResourceByID']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/ds/query': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * DataSource query metrics with expressions.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `datasources:query`.
         */
        post: operations['queryMetricsWithExpressions']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/folders': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get all folders.
         * @description It returns all folders that the authenticated user has permission to view.
         *     If nested folders are enabled, it expects an additional query parameter with the parent folder UID
         *     and returns the immediate subfolders that the authenticated user has permission to view.
         *     If the parameter is not supplied then it returns immediate subfolders under the root
         *     that the authenticated user has permission to view.
         */
        get: operations['getFolders']
        put?: never
        /**
         * Create folder.
         * @description If nested folders are enabled then it additionally expects the parent folder UID.
         */
        post: operations['createFolder']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/folders/id/{folder_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get folder by id.
         * @deprecated
         * @description Returns the folder identified by id. This is deprecated.
         *     Please refer to [updated API](#/folders/getFolderByUID) instead
         */
        get: operations['getFolderByID']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/folders/{folder_uid}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get folder by uid. */
        get: operations['getFolderByUID']
        /** Update folder. */
        put: operations['updateFolder']
        post?: never
        /**
         * Delete folder.
         * @description Deletes an existing folder identified by UID along with all dashboards (and their alerts) stored in the folder. This operation cannot be reverted.
         *     If nested folders are enabled then it also deletes all the subfolders.
         */
        delete: operations['deleteFolder']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/folders/{folder_uid}/counts': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Gets the count of each descendant of a folder by kind. The folder is identified by UID. */
        get: operations['getFolderDescendantCounts']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/folders/{folder_uid}/move': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** Move folder. */
        post: operations['moveFolder']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/folders/{folder_uid}/permissions': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Gets all existing permissions for the folder with the given `uid`. */
        get: operations['getFolderPermissionList']
        put?: never
        /** Updates permissions for a folder. This operation will remove existing permissions if they’re not included in the request. */
        post: operations['updateFolderPermissions']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/groupsync/groups': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** List groups that have mappings set. This endpoint is behind the feature flag `groupAttributeSync` and is considered experimental. */
        get: operations['getMappedGroups']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/groupsync/groups/{group_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        /** Update mappings for a group. This endpoint is behind the feature flag `groupAttributeSync` and is considered experimental. */
        put: operations['updateGroupMappings']
        /** Create mappings for a group. This endpoint is behind the feature flag `groupAttributeSync` and is considered experimental. */
        post: operations['createGroupMappings']
        /** Delete mappings for a group. This endpoint is behind the feature flag `groupAttributeSync` and is considered experimental. */
        delete: operations['deleteGroupMappings']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/groupsync/groups/{group_id}/roles': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get roles mapped to a group. This endpoint is behind the feature flag `groupAttributeSync` and is considered experimental. */
        get: operations['getGroupRoles']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/health': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description apiHealthHandler will return ok if Grafana's web server is running and it
         *     can access the database. If the database cannot be accessed it will return
         *     http status code 503. */
        get: operations['getHealth']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/library-elements': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get all library elements.
         * @description Returns a list of all library elements the authenticated user has permission to view.
         *     Use the `perPage` query parameter to control the maximum number of library elements returned; the default limit is `100`.
         *     You can also use the `page` query parameter to fetch library elements from any page other than the first one.
         */
        get: operations['getLibraryElements']
        put?: never
        /**
         * Create library element.
         * @description Creates a new library element.
         */
        post: operations['createLibraryElement']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/library-elements/name/{library_element_name}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get library element by name.
         * @description Returns a library element with the given name.
         */
        get: operations['getLibraryElementByName']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/library-elements/{library_element_uid}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get library element by UID.
         * @description Returns a library element with the given UID.
         */
        get: operations['getLibraryElementByUID']
        put?: never
        post?: never
        /**
         * Delete library element.
         * @description Deletes an existing library element as specified by the UID. This operation cannot be reverted.
         *     You cannot delete a library element that is connected. This operation cannot be reverted.
         */
        delete: operations['deleteLibraryElementByUID']
        options?: never
        head?: never
        /**
         * Update library element.
         * @description Updates an existing library element identified by uid.
         */
        patch: operations['updateLibraryElement']
        trace?: never
    }
    '/library-elements/{library_element_uid}/connections/': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get library element connections.
         * @description Returns a list of connections for a library element based on the UID specified.
         */
        get: operations['getLibraryElementConnections']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/licensing/check': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Check license availability. */
        get: operations['getStatus']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/licensing/custom-permissions': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get custom permissions report.
         * @deprecated
         * @description You need to have a permission with action `licensing.reports:read`.
         */
        get: operations['getCustomPermissionsReport']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/licensing/custom-permissions-csv': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get custom permissions report in CSV format.
         * @deprecated
         * @description You need to have a permission with action `licensing.reports:read`.
         */
        get: operations['getCustomPermissionsCSV']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/licensing/refresh-stats': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Refresh license stats.
         * @description You need to have a permission with action `licensing:read`.
         */
        get: operations['refreshLicenseStats']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/licensing/token': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get license token.
         * @description You need to have a permission with action `licensing:read`.
         */
        get: operations['getLicenseToken']
        put?: never
        /**
         * Create license token.
         * @description You need to have a permission with action `licensing:update`.
         */
        post: operations['postLicenseToken']
        /**
         * Remove license from database.
         * @description Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.
         *
         *     You need to have a permission with action `licensing:delete`.
         */
        delete: operations['deleteLicenseToken']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/licensing/token/renew': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Manually force license refresh.
         * @description Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.
         *
         *     You need to have a permission with action `licensing:update`.
         */
        post: operations['postRenewLicenseToken']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/logout/saml': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** GetLogout initiates single logout process. */
        get: operations['getSAMLLogout']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/org': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get current Organization. */
        get: operations['getCurrentOrg']
        /** Update current Organization. */
        put: operations['updateCurrentOrg']
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/org/address': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        /** Update current Organization's address. */
        put: operations['updateCurrentOrgAddress']
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/org/invites': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get pending invites. */
        get: operations['getPendingOrgInvites']
        put?: never
        /** Add invite. */
        post: operations['addOrgInvite']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/org/invites/{invitation_code}/revoke': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        /** Revoke invite. */
        delete: operations['revokeInvite']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/org/preferences': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get Current Org Prefs. */
        get: operations['getOrgPreferences']
        /** Update Current Org Prefs. */
        put: operations['updateOrgPreferences']
        post?: never
        delete?: never
        options?: never
        head?: never
        /** Patch Current Org Prefs. */
        patch: operations['patchOrgPreferences']
        trace?: never
    }
    '/org/quotas': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Fetch Organization quota.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope).
         */
        get: operations['getCurrentOrgQuota']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/org/users': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get all users within the current organization.
         * @description Returns all org users within the current organization. Accessible to users with org admin role.
         *     If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `org.users:read` with scope `users:*`.
         */
        get: operations['getOrgUsersForCurrentOrg']
        put?: never
        /**
         * Add a new user to the current organization.
         * @description Adds a global user to the current organization.
         *
         *     If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `org.users:add` with scope `users:*`.
         */
        post: operations['addOrgUserToCurrentOrg']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/org/users/lookup': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get all users within the current organization (lookup)
         * @description Returns all org users within the current organization, but with less detailed information.
         *     Accessible to users with org admin role, admin in any folder or admin of any team.
         *     Mainly used by Grafana UI for providing list of users when adding team members and when editing folder/dashboard permissions.
         */
        get: operations['getOrgUsersForCurrentOrgLookup']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/org/users/{user_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        /**
         * Delete user in current organization.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `org.users:remove` with scope `users:*`.
         */
        delete: operations['removeOrgUserForCurrentOrg']
        options?: never
        head?: never
        /**
         * Updates the given user.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `org.users.role:update` with scope `users:*`.
         */
        patch: operations['updateOrgUserForCurrentOrg']
        trace?: never
    }
    '/orgs': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Search all Organizations. */
        get: operations['searchOrgs']
        put?: never
        /**
         * Create Organization.
         * @description Only works if [users.allow_org_create](https://grafana.com/docs/grafana/latest/administration/configuration/#allow_org_create) is set.
         */
        post: operations['createOrg']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/orgs/name/{org_name}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get Organization by ID. */
        get: operations['getOrgByName']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/orgs/{org_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get Organization by ID. */
        get: operations['getOrgByID']
        /** Update Organization. */
        put: operations['updateOrg']
        post?: never
        /** Delete Organization. */
        delete: operations['deleteOrgByID']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/orgs/{org_id}/address': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        /** Update Organization's address. */
        put: operations['updateOrgAddress']
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/orgs/{org_id}/quotas': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Fetch Organization quota.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope).
         */
        get: operations['getOrgQuota']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/orgs/{org_id}/quotas/{quota_target}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        /**
         * Update user quota.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:write` and scope `org:id:1` (orgIDScope).
         */
        put: operations['updateOrgQuota']
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/orgs/{org_id}/users': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get Users in Organization.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `org.users:read` with scope `users:*`.
         */
        get: operations['getOrgUsers']
        put?: never
        /**
         * Add a new user to the current organization.
         * @description Adds a global user to the current organization.
         *
         *     If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `org.users:add` with scope `users:*`.
         */
        post: operations['addOrgUser']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/orgs/{org_id}/users/search': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Search Users in Organization.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `org.users:read` with scope `users:*`.
         */
        get: operations['searchOrgUsers']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/orgs/{org_id}/users/{user_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        /**
         * Delete user in current organization.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `org.users:remove` with scope `users:*`.
         */
        delete: operations['removeOrgUser']
        options?: never
        head?: never
        /**
         * Update Users in Organization.
         * @description If you are running Grafana Enterprise and have Fine-grained access control enabled
         *     you need to have a permission with action: `org.users.role:update` with scope `users:*`.
         */
        patch: operations['updateOrgUser']
        trace?: never
    }
    '/playlists': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get playlists. */
        get: operations['searchPlaylists']
        put?: never
        /** Create playlist. */
        post: operations['createPlaylist']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/playlists/{uid}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get playlist. */
        get: operations['getPlaylist']
        /** Update playlist. */
        put: operations['updatePlaylist']
        post?: never
        /** Delete playlist. */
        delete: operations['deletePlaylist']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/playlists/{uid}/items': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get playlist items. */
        get: operations['getPlaylistItems']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/public/dashboards/{accessToken}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description Get public dashboard for view */
        get: operations['viewPublicDashboard']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/public/dashboards/{accessToken}/annotations': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description Get annotations for a public dashboard */
        get: operations['getPublicAnnotations']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/public/dashboards/{accessToken}/panels/{panelId}/query': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** @description Get results for a given panel on a public dashboard */
        post: operations['queryPublicDashboard']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/query-history': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Query history search.
         * @description Returns a list of queries in the query history that matches the search criteria.
         *     Query history search supports pagination. Use the `limit` parameter to control the maximum number of queries returned; the default limit is 100.
         *     You can also use the `page` query parameter to fetch queries from any page other than the first one.
         */
        get: operations['searchQueries']
        put?: never
        /**
         * Add query to query history.
         * @description Adds new query to query history.
         */
        post: operations['createQuery']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/query-history/star/{query_history_uid}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Add star to query in query history.
         * @description Adds star to query in query history as specified by the UID.
         */
        post: operations['starQuery']
        /**
         * Remove star to query in query history.
         * @description Removes star from query in query history as specified by the UID.
         */
        delete: operations['unstarQuery']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/query-history/{query_history_uid}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        /**
         * Delete query in query history.
         * @description Deletes an existing query in query history as specified by the UID. This operation cannot be reverted.
         */
        delete: operations['deleteQuery']
        options?: never
        head?: never
        /**
         * Update comment for query in query history.
         * @description Updates comment for query in query history as specified by the UID.
         */
        patch: operations['patchQueryComment']
        trace?: never
    }
    '/recording-rules': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Lists all rules in the database: active or deleted. */
        get: operations['listRecordingRules']
        /** Update the active status of a rule. */
        put: operations['updateRecordingRule']
        /** Create a recording rule that is then registered and started. */
        post: operations['createRecordingRule']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/recording-rules/test': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** Test a recording rule. */
        post: operations['testCreateRecordingRule']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/recording-rules/writer': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Return the prometheus remote write target. */
        get: operations['getRecordingRuleWriteTarget']
        put?: never
        /**
         * Create a remote write target.
         * @description It returns a 422 if there is not an existing prometheus data source configured.
         */
        post: operations['createRecordingRuleWriteTarget']
        /** Delete the remote write target. */
        delete: operations['deleteRecordingRuleWriteTarget']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/recording-rules/{recordingRuleID}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        /** Delete removes the rule from the registry and stops it. */
        delete: operations['deleteRecordingRule']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/reports': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * List reports.
         * @description Available to org admins only and with a valid or expired license.
         *
         *     You need to have a permission with action `reports:read` with scope `reports:*`.
         */
        get: operations['getReports']
        put?: never
        /**
         * Create a report.
         * @description Available to org admins only and with a valid license.
         *
         *     You need to have a permission with action `reports.admin:create`.
         */
        post: operations['createReport']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/reports/email': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Send a report.
         * @description Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.
         *
         *     Only available in Grafana Enterprise v7.0+.
         *     This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.
         *
         *     You need to have a permission with action `reports:send`.
         */
        post: operations['sendReport']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/reports/images/:image': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get custom branding report image.
         * @description Available to org admins only and with a valid or expired license.
         *
         *     You need to have a permission with action `reports.settings:read`.
         */
        get: operations['getSettingsImage']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/reports/render/csvs': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Download a CSV report.
         * @description Available to all users and with a valid license.
         */
        get: operations['renderReportCSVs']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/reports/render/pdfs': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Render report for multiple dashboards.
         * @description Available to all users and with a valid license.
         */
        get: operations['renderReportPDFs']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/reports/settings': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get report settings.
         * @description Available to org admins only and with a valid or expired license.
         *
         *     You need to have a permission with action `reports.settings:read`x.
         */
        get: operations['getReportSettings']
        put?: never
        /**
         * Save settings.
         * @description Available to org admins only and with a valid or expired license.
         *
         *     You need to have a permission with action `reports.settings:write`xx.
         */
        post: operations['saveReportSettings']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/reports/test-email': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Send test report via email.
         * @description Available to org admins only and with a valid license.
         *
         *     You need to have a permission with action `reports:send`.
         */
        post: operations['sendTestEmail']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/reports/{id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get a report.
         * @deprecated
         * @description Available to org admins only and with a valid or expired license.
         *
         *     You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
         *
         *     Requesting reports using the internal id will stop workgin in the future
         *     Use the reporting apiserver to manage reports.  See: /apis/reporting.grafana.app/
         */
        get: operations['getReport']
        /**
         * Update a report.
         * @deprecated
         * @description Available to org admins only and with a valid or expired license.
         *
         *     You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
         *
         *     Requesting reports using the internal id will stop workgin in the future
         *     Use the reporting apiserver to manage reports.  See: /apis/reporting.grafana.app/
         */
        put: operations['updateReport']
        post?: never
        /**
         * Delete a report.
         * @deprecated
         * @description Available to org admins only and with a valid or expired license.
         *
         *     You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
         *
         *     Requesting reports using the internal id will stop workgin in the future
         *     Use the reporting apiserver to manage reports.  See: /apis/reporting.grafana.app/
         */
        delete: operations['deleteReport']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/saml/acs': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** It performs Assertion Consumer Service (ACS). */
        post: operations['postACS']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/saml/metadata': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** It exposes the SP (Grafana's) metadata for the IdP's consumption. */
        get: operations['getMetadata']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/saml/slo': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * It performs Single Logout (SLO) callback.
         * @description There might be two possible requests:
         *     1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request.
         *     2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana,
         *     or in case of IdP-initiated logout.
         */
        get: operations['getSLO']
        put?: never
        /**
         * It performs Single Logout (SLO) callback.
         * @description There might be two possible requests:
         *     1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request.
         *     2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana,
         *     or in case of IdP-initiated logout.
         */
        post: operations['postSLO']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/search': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get: operations['search']
        put?: never
        /** Lists all devices within the last 30 days */
        post: operations['SearchDevices']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/search/sorting': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** List search sorting options. */
        get: operations['listSortOptions']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/serviceaccounts': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Create service account
         * @description Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
         *     action: `serviceaccounts:write` scope: `serviceaccounts:*`
         *
         *     Requires basic authentication and that the authenticated user is a Grafana Admin.
         */
        post: operations['createServiceAccount']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/serviceaccounts/search': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Search service accounts with paging
         * @description Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
         *     action: `serviceaccounts:read` scope: `serviceaccounts:*`
         */
        get: operations['searchOrgServiceAccountsWithPaging']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/serviceaccounts/{serviceAccountId}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get single serviceaccount by Id
         * @description Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
         *     action: `serviceaccounts:read` scope: `serviceaccounts:id:1` (single service account)
         */
        get: operations['retrieveServiceAccount']
        put?: never
        post?: never
        /**
         * Delete service account
         * @description Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
         *     action: `serviceaccounts:delete` scope: `serviceaccounts:id:1` (single service account)
         */
        delete: operations['deleteServiceAccount']
        options?: never
        head?: never
        /**
         * Update service account
         * @description Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
         *     action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
         */
        patch: operations['updateServiceAccount']
        trace?: never
    }
    '/serviceaccounts/{serviceAccountId}/tokens': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get service account tokens
         * @description Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
         *     action: `serviceaccounts:read` scope: `global:serviceaccounts:id:1` (single service account)
         *
         *     Requires basic authentication and that the authenticated user is a Grafana Admin.
         */
        get: operations['listTokens']
        put?: never
        /**
         * CreateNewToken adds a token to a service account
         * @description Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
         *     action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
         */
        post: operations['createToken']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/serviceaccounts/{serviceAccountId}/tokens/{tokenId}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        /**
         * DeleteToken deletes service account tokens
         * @description Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
         *     action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
         *
         *     Requires basic authentication and that the authenticated user is a Grafana Admin.
         */
        delete: operations['deleteToken']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/signing-keys/keys': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get JSON Web Key Set (JWKS) with all the keys that can be used to verify tokens (public keys)
         * @description Required permissions
         *     None
         */
        get: operations['retrieveJWKS']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/snapshot/shared-options': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get snapshot sharing settings. */
        get: operations['getSharingOptions']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/snapshots': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * When creating a snapshot using the API, you have to provide the full dashboard payload including the snapshot data. This endpoint is designed for the Grafana UI.
         * @description Snapshot public mode should be enabled or authentication is required.
         */
        post: operations['createDashboardSnapshot']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/snapshots-delete/{deleteKey}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Delete Snapshot by deleteKey.
         * @description Snapshot public mode should be enabled or authentication is required.
         */
        get: operations['deleteDashboardSnapshotByDeleteKey']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/snapshots/{key}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get Snapshot by Key. */
        get: operations['getDashboardSnapshot']
        put?: never
        post?: never
        /** Delete Snapshot by Key. */
        delete: operations['deleteDashboardSnapshot']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/stats': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Lists all devices within the last 30 days */
        get: operations['listDevices']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/teams': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** Add Team. */
        post: operations['createTeam']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/teams/search': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Team Search With Paging. */
        get: operations['searchTeams']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/teams/{teamId}/groups': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get External Groups. */
        get: operations['getTeamGroupsApi']
        put?: never
        /** Add External Group. */
        post: operations['addTeamGroupApi']
        /** Remove External Group. */
        delete: operations['removeTeamGroupApiQuery']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/teams/{team_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get Team By ID. */
        get: operations['getTeamByID']
        /** Update Team. */
        put: operations['updateTeam']
        post?: never
        /** Delete Team By ID. */
        delete: operations['deleteTeamByID']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/teams/{team_id}/members': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get Team Members. */
        get: operations['getTeamMembers']
        /**
         * Set team memberships.
         * @description Takes user emails, and updates team members and admins to the provided lists of users.
         *     Any current team members and admins not in the provided lists will be removed.
         */
        put: operations['setTeamMemberships']
        /** Add Team Member. */
        post: operations['addTeamMember']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/teams/{team_id}/members/{user_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        /** Update Team Member. */
        put: operations['updateTeamMember']
        post?: never
        /** Remove Member From Team. */
        delete: operations['removeTeamMember']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/teams/{team_id}/preferences': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get Team Preferences. */
        get: operations['getTeamPreferences']
        /** Update Team Preferences. */
        put: operations['updateTeamPreferences']
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/user': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description Get (current authenticated user) */
        get: operations['getSignedInUser']
        /** Update signed in User. */
        put: operations['updateSignedInUser']
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/user/auth-tokens': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Auth tokens of the actual User.
         * @description Return a list of all auth tokens (devices) that the actual user currently have logged in from.
         */
        get: operations['getUserAuthTokens']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/user/email/update': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Update user email.
         * @description Update the email of user given a verification code.
         */
        get: operations['updateUserEmail']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/user/helpflags/clear': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Clear user help flag. */
        get: operations['clearHelpFlags']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/user/helpflags/{flag_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        /** Set user help flag. */
        put: operations['setHelpFlag']
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/user/orgs': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Organizations of the actual User.
         * @description Return a list of all organizations of the current user.
         */
        get: operations['getSignedInUserOrgList']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/user/password': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        /**
         * Change Password.
         * @description Changes the password for the user.
         */
        put: operations['changeUserPassword']
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/user/preferences': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get user preferences. */
        get: operations['getUserPreferences']
        /**
         * Update user preferences.
         * @description Omitting a key (`theme`, `homeDashboardId`, `timezone`) will cause the current value to be replaced with the system default value.
         */
        put: operations['updateUserPreferences']
        post?: never
        delete?: never
        options?: never
        head?: never
        /** Patch user preferences. */
        patch: operations['patchUserPreferences']
        trace?: never
    }
    '/user/quotas': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Fetch user quota. */
        get: operations['getUserQuotas']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/user/revoke-auth-token': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Revoke an auth token of the actual User.
         * @description Revokes the given auth token (device) for the actual user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity.
         */
        post: operations['revokeUserAuthToken']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/user/stars/dashboard/uid/{dashboard_uid}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Star a dashboard.
         * @description Stars the given Dashboard for the actual user.
         */
        post: operations['starDashboardByUID']
        /**
         * Unstar a dashboard.
         * @description Deletes the starring of the given Dashboard for the actual user.
         */
        delete: operations['unstarDashboardByUID']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/user/stars/dashboard/{dashboard_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Star a dashboard.
         * @deprecated
         * @description Stars the given Dashboard for the actual user.
         */
        post: operations['starDashboard']
        /**
         * Unstar a dashboard.
         * @deprecated
         * @description Deletes the starring of the given Dashboard for the actual user.
         */
        delete: operations['unstarDashboard']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/user/teams': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Teams that the actual User is member of.
         * @description Return a list of all teams that the current user is member of.
         */
        get: operations['getSignedInUserTeamList']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/user/using/{org_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Switch user context for signed in user.
         * @description Switch user context to the given organization.
         */
        post: operations['userSetUsingOrg']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/users': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get users.
         * @description Returns all users that the authenticated user has permission to view, admin permission required.
         */
        get: operations['searchUsers']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/users/lookup': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get user by login or email. */
        get: operations['getUserByLoginOrEmail']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/users/search': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get users with paging. */
        get: operations['searchUsersWithPaging']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/users/{user_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get user by id. */
        get: operations['getUserByID']
        /**
         * Update user.
         * @description Update the user identified by id.
         */
        put: operations['updateUser']
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/users/{user_id}/orgs': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get organizations for user.
         * @description Get organizations for user identified by id.
         */
        get: operations['getUserOrgList']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/users/{user_id}/teams': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get teams for user.
         * @description Get teams for user identified by id.
         */
        get: operations['getUserTeams']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/alert-rules': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get all the alert rules. */
        get: operations['RouteGetAlertRules']
        put?: never
        /** Create a new alert rule. */
        post: operations['RoutePostAlertRule']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/alert-rules/export': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Export all alert rules in provisioning file format. */
        get: operations['RouteGetAlertRulesExport']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/alert-rules/{UID}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get a specific alert rule by UID. */
        get: operations['RouteGetAlertRule']
        /** Update an existing alert rule. */
        put: operations['RoutePutAlertRule']
        post?: never
        /** Delete a specific alert rule by UID. */
        delete: operations['RouteDeleteAlertRule']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/alert-rules/{UID}/export': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Export an alert rule in provisioning file format. */
        get: operations['RouteGetAlertRuleExport']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/contact-points': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get all the contact points. */
        get: operations['RouteGetContactpoints']
        put?: never
        /** Create a contact point. */
        post: operations['RoutePostContactpoints']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/contact-points/export': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Export all contact points in provisioning file format. */
        get: operations['RouteGetContactpointsExport']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/contact-points/{UID}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        /** Update an existing contact point. */
        put: operations['RoutePutContactpoint']
        post?: never
        /** Delete a contact point. */
        delete: operations['RouteDeleteContactpoints']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get a rule group. */
        get: operations['RouteGetAlertRuleGroup']
        /** Create or update alert rule group. */
        put: operations['RoutePutAlertRuleGroup']
        post?: never
        /** @description Delete rule group */
        delete: operations['RouteDeleteAlertRuleGroup']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}/export': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Export an alert rule group in provisioning file format. */
        get: operations['RouteGetAlertRuleGroupExport']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/mute-timings': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get all the mute timings. */
        get: operations['RouteGetMuteTimings']
        put?: never
        /** Create a new mute timing. */
        post: operations['RoutePostMuteTiming']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/mute-timings/export': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Export all mute timings in provisioning format. */
        get: operations['RouteExportMuteTimings']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/mute-timings/{name}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get a mute timing. */
        get: operations['RouteGetMuteTiming']
        /** Replace an existing mute timing. */
        put: operations['RoutePutMuteTiming']
        post?: never
        /** Delete a mute timing. */
        delete: operations['RouteDeleteMuteTiming']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/mute-timings/{name}/export': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Export a mute timing in provisioning format. */
        get: operations['RouteExportMuteTiming']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/policies': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get the notification policy tree. */
        get: operations['RouteGetPolicyTree']
        /** Sets the notification policy tree. */
        put: operations['RoutePutPolicyTree']
        post?: never
        /** Clears the notification policy tree. */
        delete: operations['RouteResetPolicyTree']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/policies/export': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Export the notification policy tree in provisioning file format. */
        get: operations['RouteGetPolicyTreeExport']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/templates': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get all notification template groups. */
        get: operations['RouteGetTemplates']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/provisioning/templates/{name}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** Get a notification template group. */
        get: operations['RouteGetTemplate']
        /** Updates an existing notification template group. */
        put: operations['RoutePutTemplate']
        post?: never
        /** Delete a notification template group. */
        delete: operations['RouteDeleteTemplate']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/sso-settings': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * List all SSO Settings entries
         * @description You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`.
         */
        get: operations['listAllProvidersSettings']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/v1/sso-settings/{key}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Get an SSO Settings entry by Key
         * @description You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`.
         */
        get: operations['getProviderSettings']
        /**
         * Update SSO Settings
         * @description Inserts or updates the SSO Settings for a provider.
         *
         *     You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
         */
        put: operations['updateProviderSettings']
        post?: never
        /**
         * Remove SSO Settings
         * @description Removes the SSO Settings for a provider.
         *
         *     You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
         */
        delete: operations['removeProviderSettings']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
}
export type webhooks = Record<string, never>
export interface components {
    schemas: {
        Ack: Record<string, never>
        /** @description ActiveSyncStatusDTO holds the information for LDAP background Sync */
        ActiveSyncStatusDTO: {
            enabled: boolean
            /** Format: date-time */
            nextSync: string
            prevSync: components['schemas']['SyncResult']
            schedule: string
        }
        ActiveUserStats: {
            /** Format: int64 */
            active_admins_and_editors: number
            /** Format: int64 */
            active_anonymous_devices: number
            /** Format: int64 */
            active_users: number
            /** Format: int64 */
            active_viewers: number
        }
        AddAPIKeyCommand: {
            name: string
            /** @enum {string} */
            role: 'None' | 'Viewer' | 'Editor' | 'Admin'
            /** Format: int64 */
            secondsToLive: number
        }
        /** @description Also acts as api DTO */
        AddDataSourceCommand: {
            access: components['schemas']['DsAccess']
            basicAuth: boolean
            basicAuthUser: string
            database: string
            isDefault: boolean
            jsonData: components['schemas']['Json']
            name: string
            secureJsonData: {
                [key: string]: string
            }
            type: string
            uid: string
            url: string
            user: string
            withCredentials: boolean
        }
        AddInviteForm: {
            loginOrEmail: string
            name: string
            /** @enum {string} */
            role: 'None' | 'Viewer' | 'Editor' | 'Admin'
            sendEmail: boolean
        }
        AddOrgUserCommand: {
            loginOrEmail: string
            /** @enum {string} */
            role: 'None' | 'Viewer' | 'Editor' | 'Admin'
        }
        AddServiceAccountTokenCommand: {
            name: string
            /** Format: int64 */
            secondsToLive: number
        }
        AddTeamMemberCommand: {
            /** Format: int64 */
            userId: number
        }
        AddTeamRoleCommand: {
            roleUid: string
        }
        AddUserRoleCommand: {
            global: boolean
            roleUid: string
        }
        Address: {
            address1: string
            address2: string
            city: string
            country: string
            state: string
            zipCode: string
        }
        AdminCreateUserForm: {
            email: string
            login: string
            name: string
            /** Format: int64 */
            orgId: number
            password: components['schemas']['Password']
        }
        AdminCreateUserResponse: {
            /** Format: int64 */
            id: number
            message: string
            uid: string
        }
        AdminStats: {
            /** Format: int64 */
            activeAdmins: number
            /** Format: int64 */
            activeDevices: number
            /** Format: int64 */
            activeEditors: number
            /** Format: int64 */
            activeSessions: number
            /** Format: int64 */
            activeUsers: number
            /** Format: int64 */
            activeViewers: number
            /** Format: int64 */
            admins: number
            /** Format: int64 */
            alerts: number
            /** Format: int64 */
            dailyActiveAdmins: number
            /** Format: int64 */
            dailyActiveEditors: number
            /** Format: int64 */
            dailyActiveSessions: number
            /** Format: int64 */
            dailyActiveUsers: number
            /** Format: int64 */
            dailyActiveViewers: number
            /** Format: int64 */
            dashboards: number
            /** Format: int64 */
            datasources: number
            /** Format: int64 */
            editors: number
            /** Format: int64 */
            monthlyActiveUsers: number
            /** Format: int64 */
            orgs: number
            /** Format: int64 */
            playlists: number
            /** Format: int64 */
            snapshots: number
            /** Format: int64 */
            stars: number
            /** Format: int64 */
            tags: number
            /** Format: int64 */
            users: number
            /** Format: int64 */
            viewers: number
        }
        AdminUpdateUserPasswordForm: {
            password: components['schemas']['Password']
        }
        AdminUpdateUserPermissionsForm: {
            isGrafanaAdmin: boolean
        }
        /** Alert has info for an alert. */
        Alert: {
            /** Format: date-time */
            activeAt?: string
            annotations: components['schemas']['Labels']
            labels: components['schemas']['Labels']
            state: string
            value: string
        }
        /** AlertDiscovery has info for all active alerts. */
        AlertDiscovery: {
            alerts: components['schemas']['Alert'][]
        }
        AlertInstancesResponse: {
            /** @description Instances is an array of arrow encoded dataframes
             *     each frame has a single row, and a column for each instance (alert identified by unique labels) with a boolean value (firing/not firing) */
            instances: number[][]
        }
        /** AlertManager models a configured Alert Manager. */
        AlertManager: {
            url: string
        }
        AlertManagerNotReady: Record<string, never>
        /** AlertManagersResult contains the result from querying the alertmanagers endpoint. */
        AlertManagersResult: {
            activeAlertManagers: components['schemas']['AlertManager'][]
            droppedAlertManagers: components['schemas']['AlertManager'][]
        }
        /** AlertQuery represents a single query associated with an alert definition. */
        AlertQuery: {
            /** @description Grafana data source unique identifier; it should be '__expr__' for a Server Side Expression operation. */
            datasourceUid: string
            /** @description JSON is the raw JSON query and includes the above properties as well as custom properties. */
            model: Record<string, never>
            /** @description QueryType is an optional identifier for the type of query.
             *     It can be used to distinguish different types of queries. */
            queryType: string
            /** @description RefID is the unique identifier of the query, set by the frontend call. */
            refId: string
            relativeTimeRange: components['schemas']['RelativeTimeRange']
        }
        /** AlertQueryExport is the provisioned export of models.AlertQuery. */
        AlertQueryExport: {
            datasourceUid: string
            model: {
                [key: string]: unknown
            }
            queryType: string
            refId: string
            relativeTimeRange: components['schemas']['RelativeTimeRangeExport']
        }
        AlertResponse: {
            data?: components['schemas']['AlertDiscovery']
            error?: string
            errorType?: components['schemas']['ErrorType']
            status: string
        }
        AlertRuleEditorSettings: {
            simplified_notifications_section: boolean
            simplified_query_and_expressions_section: boolean
        }
        /** AlertRuleExport is the provisioned file export of models.AlertRule. */
        AlertRuleExport: {
            annotations: {
                [key: string]: string
            }
            condition: string
            dashboardUid: string
            data: components['schemas']['AlertQueryExport'][]
            /** @enum {string} */
            execErrState: 'OK' | 'Alerting' | 'Error'
            for: components['schemas']['Duration']
            isPaused: boolean
            keepFiringFor: components['schemas']['Duration']
            labels: {
                [key: string]: string
            }
            /** Format: int64 */
            missing_series_evals_to_resolve: number
            /** @enum {string} */
            noDataState: 'Alerting' | 'NoData' | 'OK'
            notification_settings: components['schemas']['AlertRuleNotificationSettingsExport']
            /** Format: int64 */
            panelId: number
            record: components['schemas']['AlertRuleRecordExport']
            title: string
            uid: string
        }
        AlertRuleGroup: {
            folderUid: string
            /** Format: int64 */
            interval: number
            rules: components['schemas']['ProvisionedAlertRule'][]
            title: string
        }
        /** AlertRuleGroupExport is the provisioned file export of AlertRuleGroupV1. */
        AlertRuleGroupExport: {
            folder: string
            interval: components['schemas']['Duration']
            name: string
            /** Format: int64 */
            orgId: number
            rules: components['schemas']['AlertRuleExport'][]
        }
        AlertRuleGroupMetadata: {
            /** Format: int64 */
            interval: number
        }
        AlertRuleMetadata: {
            editor_settings: components['schemas']['AlertRuleEditorSettings']
        }
        AlertRuleNotificationSettings: {
            /**
             * @description Override the labels by which incoming alerts are grouped together. For example, multiple alerts coming in for
             *     cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels
             *     use the special value '...' as the sole label name.
             *     This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what
             *     you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
             *     Must include 'alertname' and 'grafana_folder' if not using '...'.
             * @default [
             *       "alertname",
             *       "grafana_folder"
             *     ]
             * @example [
             *       "alertname",
             *       "grafana_folder",
             *       "cluster"
             *     ]
             */
            group_by: string[]
            /**
             * @description Override how long to wait before sending a notification about new alerts that are added to a group of alerts for
             *     which an initial notification has already been sent. (Usually ~5m or more.)
             * @example 5m
             */
            group_interval?: string
            /**
             * @description Override how long to initially wait to send a notification for a group of alerts. Allows to wait for an
             *     inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)
             * @example 30s
             */
            group_wait?: string
            /**
             * @description Override the times when notifications should be muted. These must match the name of a mute time interval defined
             *     in the alertmanager configuration mute_time_intervals section. When muted it will not send any notifications, but
             *     otherwise acts normally.
             * @example [
             *       "maintenance"
             *     ]
             */
            mute_time_intervals?: string[]
            /**
             * @description Name of the receiver to send notifications to.
             * @example grafana-default-email
             */
            receiver: string
            /**
             * @description Override how long to wait before sending a notification again if it has already been sent successfully for an
             *     alert. (Usually ~3h or more).
             *     Note that this parameter is implicitly bound by Alertmanager's `--data.retention` configuration flag.
             *     Notifications will be resent after either repeat_interval or the data retention period have passed, whichever
             *     occurs first. `repeat_interval` should not be less than `group_interval`.
             * @example 4h
             */
            repeat_interval?: string
        }
        /** AlertRuleNotificationSettingsExport is the provisioned export of models.NotificationSettings. */
        AlertRuleNotificationSettingsExport: {
            group_by: string[]
            group_interval: string
            group_wait: string
            mute_time_intervals: string[]
            receiver: string
            repeat_interval: string
        }
        /** Record is the provisioned export of models.Record. */
        AlertRuleRecordExport: {
            from: string
            metric: string
            targetDatasourceUid: string
        }
        /** AlertingFileExport is the full provisioned file export. */
        AlertingFileExport: {
            /** Format: int64 */
            apiVersion: number
            contactPoints: components['schemas']['ContactPointExport'][]
            groups: components['schemas']['AlertRuleGroupExport'][]
            muteTimes: components['schemas']['MuteTimeIntervalExport'][]
            policies: components['schemas']['NotificationPolicyExport'][]
        }
        /** @description adapted from cortex */
        AlertingRule: {
            /** Format: date-time */
            activeAt: string
            alerts?: components['schemas']['Alert'][]
            annotations: components['schemas']['Labels']
            /** Format: double */
            duration?: number
            /** Format: double */
            evaluationTime?: number
            folderUid: string
            health: string
            /** Format: double */
            keepFiringFor?: number
            labels?: components['schemas']['Labels']
            lastError?: string
            /** Format: date-time */
            lastEvaluation?: string
            name: string
            query: string
            /** @description State can be "pending", "firing", "inactive". */
            state: string
            totals?: {
                [key: string]: number
            }
            totalsFiltered?: {
                [key: string]: number
            }
            type: string
            uid: string
        }
        AlertingStatus: {
            /** @enum {string} */
            alertmanagersChoice: 'all' | 'internal' | 'external'
            /** Format: int64 */
            numExternalAlertmanagers: number
        }
        Annotation: {
            /** Format: int64 */
            alertId: number
            alertName: string
            avatarUrl: string
            /** Format: int64 */
            created: number
            /** Format: int64 */
            dashboardId: number
            dashboardUID: string
            data: components['schemas']['Json']
            email: string
            /** Format: int64 */
            id: number
            login: string
            newState: string
            /** Format: int64 */
            panelId: number
            prevState: string
            tags: string[]
            text: string
            /** Format: int64 */
            time: number
            /** Format: int64 */
            timeEnd: number
            /** Format: int64 */
            updated: number
            /** Format: int64 */
            userId: number
        }
        /** @description +k8s:deepcopy-gen=true */
        AnnotationActions: {
            canAdd: boolean
            canDelete: boolean
            canEdit: boolean
        }
        AnnotationEvent: {
            color: string
            /** Format: int64 */
            dashboardId: number
            /** Format: int64 */
            id: number
            isRegion: boolean
            /** Format: int64 */
            panelId: number
            source: components['schemas']['AnnotationQuery']
            tags: string[]
            text: string
            /** Format: int64 */
            time: number
            /** Format: int64 */
            timeEnd: number
        }
        AnnotationPanelFilter: {
            /** @description Should the specified panels be included or excluded */
            exclude: boolean
            /** @description Panel IDs that should be included or excluded */
            ids: number[]
        }
        /** @description +k8s:deepcopy-gen=true */
        AnnotationPermission: {
            dashboard: components['schemas']['AnnotationActions']
            organization: components['schemas']['AnnotationActions']
        }
        /** @description TODO docs
         *     FROM: AnnotationQuery in grafana-data/src/types/annotations.ts */
        AnnotationQuery: {
            /**
             * Format: double
             * @description Set to 1 for the standard annotation query all dashboards have by default.
             */
            builtIn: number
            datasource: components['schemas']['DataSourceRef']
            /** @description When enabled the annotation query is issued with every dashboard refresh */
            enable: boolean
            filter: components['schemas']['AnnotationPanelFilter']
            /** @description Annotation queries can be toggled on or off at the top of the dashboard.
             *     When hide is true, the toggle is not shown in the dashboard. */
            hide: boolean
            /** @description Color to use for the annotation event markers */
            iconColor: string
            /** @description Name of annotation. */
            name: string
            target: components['schemas']['AnnotationTarget']
            /** @description TODO -- this should not exist here, it is based on the --grafana-- datasource */
            type: string
        }
        /** @description TODO: this should be a regular DataQuery that depends on the selected dashboard
         *     these match the properties of the "grafana" datasouce that is default in most dashboards */
        AnnotationTarget: {
            /**
             * Format: int64
             * @description Only required/valid for the grafana datasource...
             *     but code+tests is already depending on it so hard to change
             */
            limit: number
            /** @description Only required/valid for the grafana datasource...
             *     but code+tests is already depending on it so hard to change */
            matchAny: boolean
            /** @description Only required/valid for the grafana datasource...
             *     but code+tests is already depending on it so hard to change */
            tags: string[]
            /** @description Only required/valid for the grafana datasource...
             *     but code+tests is already depending on it so hard to change */
            type: string
        }
        ApiKeyDTO: {
            accessControl: components['schemas']['Metadata']
            /** Format: date-time */
            expiration: string
            /** Format: int64 */
            id: number
            /** Format: date-time */
            lastUsedAt: string
            name: string
            /** @enum {string} */
            role: 'None' | 'Viewer' | 'Editor' | 'Admin'
        }
        ApiRuleNode: {
            alert: string
            annotations: {
                [key: string]: string
            }
            expr: string
            for: string
            keep_firing_for: string
            labels: {
                [key: string]: string
            }
            record: string
        }
        Assignments: {
            builtInRoles: boolean
            serviceAccounts: boolean
            teams: boolean
            users: boolean
        }
        /** @description AttributeTypeAndValue mirrors the ASN.1 structure of the same name in
         *     RFC 5280, Section 4.1.2.4. */
        AttributeTypeAndValue: {
            Type: components['schemas']['ObjectIdentifier']
            Value: unknown
        }
        /** Authorization contains HTTP authorization credentials. */
        Authorization: {
            credentials: components['schemas']['Secret']
            credentials_file: string
            /** @description CredentialsRef is the name of the secret within the secret manager to use as credentials. */
            credentials_ref: string
            type: string
        }
        BacktestConfig: {
            annotations: {
                [key: string]: string
            }
            condition: string
            data: components['schemas']['AlertQuery'][]
            for: components['schemas']['Duration']
            /** Format: date-time */
            from: string
            interval: components['schemas']['Duration']
            labels: {
                [key: string]: string
            }
            /** @enum {string} */
            no_data_state: 'Alerting' | 'NoData' | 'OK'
            title: string
            /** Format: date-time */
            to: string
        }
        BacktestResult: components['schemas']['Frame']
        /** BasicAuth contains basic HTTP authentication credentials. */
        BasicAuth: {
            password: components['schemas']['Secret']
            password_file: string
            /** @description PasswordRef is the name of the secret within the secret manager to use as the password. */
            password_ref: string
            username: string
            username_file: string
            /** @description UsernameRef is the name of the secret within the secret manager to use as the username. */
            username_ref: string
        }
        /** @description Config defines the internal representation of a cache configuration, including fields not set by the API caller */
        CacheConfig: {
            /** Format: date-time */
            created: string
            /**
             * Format: int64
             * @description Fields that can be set by the API caller - read/write
             */
            dataSourceID: number
            dataSourceUID: string
            /**
             * Format: int64
             * @description These are returned by the HTTP API, but are managed internally - read-only
             *     Note: 'created' and 'updated' are special properties managed automatically by xorm, but we are setting them manually
             */
            defaultTTLMs: number
            enabled: boolean
            /**
             * Format: int64
             * @description TTL MS, or "time to live", is how long a cached item will stay in the cache before it is removed (in milliseconds)
             */
            ttlQueriesMs: number
            /** Format: int64 */
            ttlResourcesMs: number
            /** Format: date-time */
            updated: string
            /** @description If UseDefaultTTL is enabled, then the TTLQueriesMS and TTLResourcesMS in this object is always sent as the default TTL located in grafana.ini */
            useDefaultTTL: boolean
        }
        CacheConfigResponse: {
            /** Format: date-time */
            created: string
            /**
             * Format: int64
             * @description Fields that can be set by the API caller - read/write
             */
            dataSourceID: number
            dataSourceUID: string
            /**
             * Format: int64
             * @description These are returned by the HTTP API, but are managed internally - read-only
             *     Note: 'created' and 'updated' are special properties managed automatically by xorm, but we are setting them manually
             */
            defaultTTLMs: number
            enabled: boolean
            message: string
            /**
             * Format: int64
             * @description TTL MS, or "time to live", is how long a cached item will stay in the cache before it is removed (in milliseconds)
             */
            ttlQueriesMs: number
            /** Format: int64 */
            ttlResourcesMs: number
            /** Format: date-time */
            updated: string
            /** @description If UseDefaultTTL is enabled, then the TTLQueriesMS and TTLResourcesMS in this object is always sent as the default TTL located in grafana.ini */
            useDefaultTTL: boolean
        }
        /** @description ConfigSetter defines the cache parameters that users can configure per datasource
         *     This is only intended to be consumed by the SetCache HTTP Handler */
        CacheConfigSetter: {
            /** Format: int64 */
            dataSourceID: number
            dataSourceUID: string
            enabled: boolean
            /**
             * Format: int64
             * @description TTL MS, or "time to live", is how long a cached item will stay in the cache before it is removed (in milliseconds)
             */
            ttlQueriesMs: number
            /** Format: int64 */
            ttlResourcesMs: number
            /** @description If UseDefaultTTL is enabled, then the TTLQueriesMS and TTLResourcesMS in this object is always sent as the default TTL located in grafana.ini */
            useDefaultTTL: boolean
        }
        CalculateDiffTarget: {
            /** Format: int64 */
            dashboardId: number
            unsavedDashboard: components['schemas']['Json']
            /** Format: int64 */
            version: number
        }
        /** A Certificate represents an X.509 certificate. */
        Certificate: {
            AuthorityKeyId: number[]
            /** @description BasicConstraintsValid indicates whether IsCA, MaxPathLen,
             *     and MaxPathLenZero are valid. */
            BasicConstraintsValid: boolean
            /** @description CRL Distribution Points */
            CRLDistributionPoints: string[]
            /** @description Subject Alternate Name values. (Note that these values may not be valid
             *     if invalid values were contained within a parsed certificate. For
             *     example, an element of DNSNames may not be a valid DNS domain name.) */
            DNSNames: string[]
            EmailAddresses: string[]
            ExcludedDNSDomains: string[]
            ExcludedEmailAddresses: string[]
            ExcludedIPRanges: components['schemas']['IPNet'][]
            ExcludedURIDomains: string[]
            ExtKeyUsage: components['schemas']['ExtKeyUsage'][]
            /** @description Extensions contains raw X.509 extensions. When parsing certificates,
             *     this can be used to extract non-critical extensions that are not
             *     parsed by this package. When marshaling certificates, the Extensions
             *     field is ignored, see ExtraExtensions. */
            Extensions: components['schemas']['Extension'][]
            /** @description ExtraExtensions contains extensions to be copied, raw, into any
             *     marshaled certificates. Values override any extensions that would
             *     otherwise be produced based on the other fields. The ExtraExtensions
             *     field is not populated when parsing certificates, see Extensions. */
            ExtraExtensions: components['schemas']['Extension'][]
            IPAddresses: string[]
            /**
             * Format: int64
             * @description InhibitAnyPolicy and InhibitAnyPolicyZero indicate the presence and value
             *     of the inhibitAnyPolicy extension.
             *
             *     The value of InhibitAnyPolicy indicates the number of additional
             *     certificates in the path after this certificate that may use the
             *     anyPolicy policy OID to indicate a match with any other policy.
             *
             *     When parsing a certificate, a positive non-zero InhibitAnyPolicy means
             *     that the field was specified, -1 means it was unset, and
             *     InhibitAnyPolicyZero being true mean that the field was explicitly set to
             *     zero. The case of InhibitAnyPolicy==0 with InhibitAnyPolicyZero==false
             *     should be treated equivalent to -1 (unset).
             */
            InhibitAnyPolicy: number
            /** @description InhibitAnyPolicyZero indicates that InhibitAnyPolicy==0 should be
             *     interpreted as an actual maximum path length of zero. Otherwise, that
             *     combination is interpreted as InhibitAnyPolicy not being set. */
            InhibitAnyPolicyZero: boolean
            /**
             * Format: int64
             * @description InhibitPolicyMapping and InhibitPolicyMappingZero indicate the presence
             *     and value of the inhibitPolicyMapping field of the policyConstraints
             *     extension.
             *
             *     The value of InhibitPolicyMapping indicates the number of additional
             *     certificates in the path after this certificate that may use policy
             *     mapping.
             *
             *     When parsing a certificate, a positive non-zero InhibitPolicyMapping
             *     means that the field was specified, -1 means it was unset, and
             *     InhibitPolicyMappingZero being true mean that the field was explicitly
             *     set to zero. The case of InhibitPolicyMapping==0 with
             *     InhibitPolicyMappingZero==false should be treated equivalent to -1
             *     (unset).
             */
            InhibitPolicyMapping: number
            /** @description InhibitPolicyMappingZero indicates that InhibitPolicyMapping==0 should be
             *     interpreted as an actual maximum path length of zero. Otherwise, that
             *     combination is interpreted as InhibitAnyPolicy not being set. */
            InhibitPolicyMappingZero: boolean
            IsCA: boolean
            Issuer: components['schemas']['Name']
            IssuingCertificateURL: string[]
            KeyUsage: components['schemas']['KeyUsage']
            /**
             * Format: int64
             * @description MaxPathLen and MaxPathLenZero indicate the presence and
             *     value of the BasicConstraints' "pathLenConstraint".
             *
             *     When parsing a certificate, a positive non-zero MaxPathLen
             *     means that the field was specified, -1 means it was unset,
             *     and MaxPathLenZero being true mean that the field was
             *     explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false
             *     should be treated equivalent to -1 (unset).
             *
             *     When generating a certificate, an unset pathLenConstraint
             *     can be requested with either MaxPathLen == -1 or using the
             *     zero value for both MaxPathLen and MaxPathLenZero.
             */
            MaxPathLen: number
            /** @description MaxPathLenZero indicates that BasicConstraintsValid==true
             *     and MaxPathLen==0 should be interpreted as an actual
             *     maximum path length of zero. Otherwise, that combination is
             *     interpreted as MaxPathLen not being set. */
            MaxPathLenZero: boolean
            /** Format: date-time */
            NotBefore: string
            /** @description RFC 5280, 4.2.2.1 (Authority Information Access) */
            OCSPServer: string[]
            PermittedDNSDomains: string[]
            /** @description Name constraints */
            PermittedDNSDomainsCritical: boolean
            PermittedEmailAddresses: string[]
            PermittedIPRanges: components['schemas']['IPNet'][]
            PermittedURIDomains: string[]
            /** @description Policies contains all policy identifiers included in the certificate.
             *     See CreateCertificate for context about how this field and the PolicyIdentifiers field
             *     interact.
             *     In Go 1.22, encoding/gob cannot handle and ignores this field. */
            Policies: string[]
            /** @description PolicyIdentifiers contains asn1.ObjectIdentifiers, the components
             *     of which are limited to int32. If a certificate contains a policy which
             *     cannot be represented by asn1.ObjectIdentifier, it will not be included in
             *     PolicyIdentifiers, but will be present in Policies, which contains all parsed
             *     policy OIDs.
             *     See CreateCertificate for context about how this field and the Policies field
             *     interact. */
            PolicyIdentifiers: components['schemas']['ObjectIdentifier'][]
            /** @description PolicyMappings contains a list of policy mappings included in the certificate. */
            PolicyMappings: components['schemas']['PolicyMapping'][]
            PublicKey: unknown
            PublicKeyAlgorithm: components['schemas']['PublicKeyAlgorithm']
            Raw: number[]
            RawIssuer: number[]
            RawSubject: number[]
            RawSubjectPublicKeyInfo: number[]
            RawTBSCertificate: number[]
            /**
             * Format: int64
             * @description RequireExplicitPolicy and RequireExplicitPolicyZero indicate the presence
             *     and value of the requireExplicitPolicy field of the policyConstraints
             *     extension.
             *
             *     The value of RequireExplicitPolicy indicates the number of additional
             *     certificates in the path after this certificate before an explicit policy
             *     is required for the rest of the path. When an explicit policy is required,
             *     each subsequent certificate in the path must contain a required policy OID,
             *     or a policy OID which has been declared as equivalent through the policy
             *     mapping extension.
             *
             *     When parsing a certificate, a positive non-zero RequireExplicitPolicy
             *     means that the field was specified, -1 means it was unset, and
             *     RequireExplicitPolicyZero being true mean that the field was explicitly
             *     set to zero. The case of RequireExplicitPolicy==0 with
             *     RequireExplicitPolicyZero==false should be treated equivalent to -1
             *     (unset).
             */
            RequireExplicitPolicy: number
            /** @description RequireExplicitPolicyZero indicates that RequireExplicitPolicy==0 should be
             *     interpreted as an actual maximum path length of zero. Otherwise, that
             *     combination is interpreted as InhibitAnyPolicy not being set. */
            RequireExplicitPolicyZero: boolean
            SerialNumber: string
            Signature: number[]
            SignatureAlgorithm: components['schemas']['SignatureAlgorithm']
            Subject: components['schemas']['Name']
            SubjectKeyId: number[]
            URIs: components['schemas']['URL'][]
            /** @description UnhandledCriticalExtensions contains a list of extension IDs that
             *     were not (fully) processed when parsing. Verify will fail if this
             *     slice is non-empty, unless verification is delegated to an OS
             *     library which understands all the critical extensions.
             *
             *     Users can access these extensions using Extensions and can remove
             *     elements from this slice if they believe that they have been
             *     handled. */
            UnhandledCriticalExtensions: components['schemas']['ObjectIdentifier'][]
            UnknownExtKeyUsage: components['schemas']['ObjectIdentifier'][]
            /** Format: int64 */
            Version: number
        }
        ChangeUserPasswordCommand: {
            newPassword: components['schemas']['Password']
            oldPassword: components['schemas']['Password']
        }
        CloudMigrationRunListDTO: {
            runs: components['schemas']['MigrateDataResponseListDTO'][]
        }
        CloudMigrationSessionListResponseDTO: {
            sessions: components['schemas']['CloudMigrationSessionResponseDTO'][]
        }
        CloudMigrationSessionRequestDTO: {
            authToken: string
        }
        CloudMigrationSessionResponseDTO: {
            /** Format: date-time */
            created: string
            slug: string
            uid: string
            /** Format: date-time */
            updated: string
        }
        /**
         * Format: double
         * @description ConfFloat64 is a float64. It Marshals float64 values of NaN of Inf
         *     to null.
         */
        ConfFloat64: number
        /** Config is the top-level configuration for Alertmanager's config files. */
        Config: {
            global: components['schemas']['GlobalConfig']
            inhibit_rules: components['schemas']['InhibitRule'][]
            /** @description MuteTimeIntervals is deprecated and will be removed before Alertmanager 1.0. */
            mute_time_intervals: components['schemas']['MuteTimeInterval'][]
            route: components['schemas']['Route']
            templates: string[]
            time_intervals: components['schemas']['TimeInterval'][]
        }
        /** ContactPointExport is the provisioned file export of alerting.ContactPointV1. */
        ContactPointExport: {
            name: string
            /** Format: int64 */
            orgId: number
            receivers: components['schemas']['ReceiverExport'][]
        }
        ContactPoints: components['schemas']['EmbeddedContactPoint'][]
        ConvertPrometheusResponse: {
            error: string
            errorType: string
            status: string
        }
        CookiePreferences: {
            analytics: unknown
            functional: unknown
            performance: unknown
        }
        CookieType: string
        /** @description Correlation is the model for correlations definitions */
        Correlation: {
            config: components['schemas']['CorrelationConfig']
            /**
             * @description Description of the correlation
             * @example Logs to Traces
             */
            description: string
            /**
             * @description Label identifying the correlation
             * @example My Label
             */
            label: string
            /**
             * Format: int64
             * @description OrgID of the data source the correlation originates from
             * @example 1
             */
            orgId: number
            /** @description Provisioned True if the correlation was created during provisioning */
            provisioned: boolean
            /**
             * @description UID of the data source the correlation originates from
             * @example d0oxYRg4z
             */
            sourceUID: string
            /**
             * @description UID of the data source the correlation points to
             * @example PE1C5CBDA0504A6A3
             */
            targetUID: string
            type: components['schemas']['CorrelationType']
            /**
             * @description Unique identifier of the correlation
             * @example 50xhMlg9k
             */
            uid: string
        }
        CorrelationConfig: {
            /**
             * @description Field used to attach the correlation link
             * @example message
             */
            field: string
            /**
             * @description Target data query
             * @example {
             *       "prop1": "value1",
             *       "prop2": "value"
             *     }
             */
            target: {
                [key: string]: unknown
            }
            transformations?: components['schemas']['Transformations']
            type?: components['schemas']['CorrelationType']
        }
        CorrelationConfigUpdateDTO: {
            /**
             * @description Field used to attach the correlation link
             * @example message
             */
            field: string
            /**
             * @description Target data query
             * @example {
             *       "prop1": "value1",
             *       "prop2": "value"
             *     }
             */
            target: {
                [key: string]: unknown
            }
            /**
             * @description Source data transformations
             * @example [
             *       {
             *         "type": "logfmt"
             *       },
             *       {
             *         "expression": "(Superman|Batman)",
             *         "type": "regex",
             *         "variable": "name"
             *       }
             *     ]
             */
            transformations: components['schemas']['Transformation'][]
        }
        /** @description the type of correlation, either query for containing query information, or external for containing an external URL
         *     +enum */
        CorrelationType: string
        /**
         * CounterResetHint contains the known information about a counter reset,
         * Format: uint8
         * @description or alternatively that we are dealing with a gauge histogram, where counter resets do not apply.
         */
        CounterResetHint: number
        CreateAccessTokenResponseDTO: {
            token: string
        }
        /** @description CreateCorrelationCommand is the command for creating a correlation */
        CreateCorrelationCommand: {
            config: components['schemas']['CorrelationConfig']
            /**
             * @description Optional description of the correlation
             * @example Logs to Traces
             */
            description: string
            /**
             * @description Optional label identifying the correlation
             * @example My label
             */
            label: string
            /** @description True if correlation was created with provisioning. This makes it read-only. */
            provisioned: boolean
            /**
             * @description Target data source UID to which the correlation is created. required if type = query
             * @example PE1C5CBDA0504A6A3
             */
            targetUID: string
            type: components['schemas']['CorrelationType']
        }
        /** @description CreateCorrelationResponse is the response struct for CreateCorrelationCommand */
        CreateCorrelationResponseBody: {
            /** @example Correlation created */
            message: string
            result: components['schemas']['Correlation']
        }
        CreateDashboardSnapshotCommand: {
            /** @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             *     +optional */
            apiVersion?: string
            dashboard: components['schemas']['Unstructured']
            /** @description Unique key used to delete the snapshot. It is different from the `key` so that only the creator can delete the snapshot. Required if `external` is `true`. */
            deleteKey?: string
            /**
             * Format: int64
             * @description When the snapshot should expire in seconds in seconds. Default is never to expire.
             * @default 0
             */
            expires: number
            /**
             * @description these are passed when storing an external snapshot ref
             *     Save the snapshot on an external server rather than locally.
             * @default false
             */
            external: boolean
            /** @description Define the unique key. Required if `external` is `true`. */
            key?: string
            /** @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             *     +optional */
            kind?: string
            /** @description Snapshot name */
            name?: string
        }
        /** @description CreateFolderCommand captures the information required by the folder service
         *     to create a folder. */
        CreateFolderCommand: {
            description: string
            parentUid: string
            title: string
            uid: string
        }
        /** @description CreateLibraryElementCommand is the command for adding a LibraryElement */
        CreateLibraryElementCommand: {
            /**
             * Format: int64
             * @description ID of the folder where the library element is stored.
             *
             *     Deprecated: use FolderUID instead
             */
            folderId: number
            /** @description UID of the folder where the library element is stored. */
            folderUid: string
            /**
             * Format: int64
             * @description Kind of element to create, Use 1 for library panels or 2 for c.
             *     Description:
             *     1 - library panels
             *     2 - library variables
             * @enum {integer}
             */
            kind: 1 | 2
            /** @description The JSON model for the library element. */
            model: Record<string, never>
            /** @description Name of the library element. */
            name: string
            uid: string
        }
        CreateOrUpdateReport: {
            dashboards: components['schemas']['ReportDashboard'][]
            enableCsv: boolean
            enableDashboardUrl: boolean
            formats: components['schemas']['Type'][]
            message: string
            name: string
            options: components['schemas']['ReportOptions']
            recipients: string
            replyTo: string
            /** Format: int64 */
            scaleFactor: number
            schedule: components['schemas']['ReportSchedule']
            state: components['schemas']['State']
            subject: string
        }
        CreateOrgCommand: {
            name: string
        }
        CreatePlaylistCommand: {
            interval: string
            items: components['schemas']['PlaylistItem'][]
            name: string
        }
        /** @description CreateQueryInQueryHistoryCommand is the command for adding query history */
        CreateQueryInQueryHistoryCommand: {
            /**
             * @description UID of the data source for which are queries stored.
             * @example PE1C5CBDA0504A6A3
             */
            datasourceUid?: string
            queries: components['schemas']['Json']
        }
        CreateRoleForm: {
            description: string
            displayName: string
            global: boolean
            group: string
            hidden: boolean
            name: string
            permissions: components['schemas']['Permission'][]
            uid: string
            /** Format: int64 */
            version: number
        }
        CreateServiceAccountForm: {
            /** @example false */
            isDisabled: boolean
            /** @example grafana */
            name: string
            /**
             * @example Admin
             * @enum {string}
             */
            role: 'None' | 'Viewer' | 'Editor' | 'Admin'
        }
        CreateSnapshotRequestDTO: {
            resourceTypes: (
                | 'DASHBOARD'
                | 'DATASOURCE'
                | 'FOLDER'
                | 'LIBRARY_ELEMENT'
                | 'ALERT_RULE'
                | 'ALERT_RULE_GROUP'
                | 'CONTACT_POINT'
                | 'NOTIFICATION_POLICY'
                | 'NOTIFICATION_TEMPLATE'
                | 'MUTE_TIMING'
                | 'PLUGIN'
            )[]
        }
        CreateSnapshotResponseDTO: {
            uid: string
        }
        CreateTeamCommand: {
            email: string
            name: string
        }
        DashboardACLInfoDTO: {
            /** Format: date-time */
            created: string
            /** Format: int64 */
            dashboardId: number
            /**
             * Format: int64
             * @description Deprecated: use FolderUID instead
             */
            folderId: number
            folderUid: string
            inherited: boolean
            isFolder: boolean
            permission: components['schemas']['PermissionType']
            permissionName: string
            /** @enum {string} */
            role: 'None' | 'Viewer' | 'Editor' | 'Admin'
            slug: string
            team: string
            teamAvatarUrl: string
            teamEmail: string
            /** Format: int64 */
            teamId: number
            teamUid: string
            title: string
            uid: string
            /** Format: date-time */
            updated: string
            url: string
            userAvatarUrl: string
            userEmail: string
            /** Format: int64 */
            userId: number
            userLogin: string
            userUid: string
        }
        DashboardACLUpdateItem: {
            permission: components['schemas']['PermissionType']
            /** @enum {string} */
            role: 'None' | 'Viewer' | 'Editor' | 'Admin'
            /** Format: int64 */
            teamId: number
            /** Format: int64 */
            userId: number
        }
        /** @description These are the values expected to be sent from an end user
         *     +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object */
        DashboardCreateCommand: {
            /** @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             *     +optional */
            apiVersion?: string
            dashboard: components['schemas']['Unstructured']
            /**
             * Format: int64
             * @description When the snapshot should expire in seconds in seconds. Default is never to expire.
             * @default 0
             */
            expires: number
            /**
             * @description these are passed when storing an external snapshot ref
             *     Save the snapshot on an external server rather than locally.
             * @default false
             */
            external: boolean
            /** @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             *     +optional */
            kind?: string
            /** @description Snapshot name */
            name?: string
        }
        DashboardFullWithMeta: {
            dashboard: components['schemas']['Json']
            meta: components['schemas']['DashboardMeta']
        }
        DashboardMeta: {
            annotationsPermissions: components['schemas']['AnnotationPermission']
            apiVersion: string
            canAdmin: boolean
            canDelete: boolean
            canEdit: boolean
            canSave: boolean
            canStar: boolean
            /** Format: date-time */
            created: string
            createdBy: string
            /** Format: date-time */
            expires: string
            /**
             * Format: int64
             * @description Deprecated: use FolderUID instead
             */
            folderId: number
            folderTitle: string
            folderUid: string
            folderUrl: string
            hasAcl: boolean
            isFolder: boolean
            isSnapshot: boolean
            isStarred: boolean
            provisioned: boolean
            provisionedExternalId: string
            publicDashboardEnabled: boolean
            slug: string
            type: string
            /** Format: date-time */
            updated: string
            updatedBy: string
            url: string
            /** Format: int64 */
            version: number
        }
        DashboardRedirect: {
            redirectUri: string
        }
        /** @description DashboardSnapshotDTO without dashboard map */
        DashboardSnapshotDTO: {
            /** Format: date-time */
            created: string
            /** Format: date-time */
            expires: string
            external: boolean
            externalUrl: string
            key: string
            name: string
            /** Format: date-time */
            updated: string
        }
        DashboardTagCloudItem: {
            /** Format: int64 */
            count: number
            term: string
        }
        /** @description DashboardVersionMeta extends the DashboardVersionDTO with the names
         *     associated with the UserIds, overriding the field with the same name from
         *     the DashboardVersionDTO model. */
        DashboardVersionMeta: {
            /** Format: date-time */
            created: string
            createdBy: string
            /** Format: int64 */
            dashboardId: number
            data: components['schemas']['Json']
            /** Format: int64 */
            id: number
            message: string
            /** Format: int64 */
            parentVersion: number
            /** Format: int64 */
            restoredFrom: number
            uid: string
            /** Format: int64 */
            version: number
        }
        /** @description DataLink define what */
        DataLink: {
            internal: components['schemas']['InternalDataLink']
            targetBlank: boolean
            title: string
            url: string
        }
        /**
         * DataResponse contains the results from a DataQuery.
         * @description A map of RefIDs (unique query identifiers) to this type makes up the Responses property of a QueryDataResponse.
         *     The Error property is used to allow for partial success responses from the containing QueryDataResponse.
         */
        DataResponse: {
            /** @description Error is a property to be set if the corresponding DataQuery has an error. */
            Error: string
            ErrorSource: components['schemas']['Source']
            Frames: components['schemas']['Frames']
            Status: components['schemas']['Status']
        }
        DataSource: {
            access: components['schemas']['DsAccess']
            accessControl: components['schemas']['Metadata']
            basicAuth: boolean
            basicAuthUser: string
            database: string
            /** Format: int64 */
            id: number
            isDefault: boolean
            jsonData: components['schemas']['Json']
            name: string
            /** Format: int64 */
            orgId: number
            readOnly: boolean
            secureJsonFields: {
                [key: string]: boolean
            }
            type: string
            typeLogoUrl: string
            uid: string
            url: string
            user: string
            /** Format: int64 */
            version: number
            withCredentials: boolean
        }
        DataSourceList: components['schemas']['DataSourceListItemDTO'][]
        DataSourceListItemDTO: {
            access: components['schemas']['DsAccess']
            basicAuth: boolean
            database: string
            /** Format: int64 */
            id: number
            isDefault: boolean
            jsonData: components['schemas']['Json']
            name: string
            /** Format: int64 */
            orgId: number
            readOnly: boolean
            type: string
            typeLogoUrl: string
            typeName: string
            uid: string
            url: string
            user: string
        }
        /** @description Ref to a DataSource instance */
        DataSourceRef: {
            /** @description The plugin type-id */
            type: string
            /** @description Specific datasource instance */
            uid: string
        }
        /**
         * DataTopic is used to identify which topic the frame should be assigned to.
         * @description nolint:revive
         */
        DataTopic: string
        DeleteCorrelationResponseBody: {
            /** @example Correlation deleted */
            message: string
        }
        DeleteTokenCommand: {
            instance: string
        }
        DescendantCounts: {
            [key: string]: number
        }
        Description: {
            assignments: components['schemas']['Assignments']
            permissions: string[]
        }
        DeviceSearchHitDTO: {
            clientIp: string
            /** Format: date-time */
            createdAt: string
            deviceId: string
            /** Format: date-time */
            lastSeenAt: string
            /** Format: date-time */
            updatedAt: string
            userAgent: string
        }
        /** DiscordConfig configures notifications via Discord. */
        DiscordConfig: {
            http_config: components['schemas']['HTTPClientConfig']
            message: string
            send_resolved: boolean
            title: string
            webhook_url: components['schemas']['SecretURL']
            webhook_url_file: string
        }
        DiscoveryBase: {
            error?: string
            errorType?: components['schemas']['ErrorType']
            status: string
        }
        DsAccess: string
        /**
         * Format: int64
         * @description Datasource permission
         *     Description:
         *     `0` - No Access
         *     `1` - Query
         *     `2` - Edit
         *     Enum: 0,1,2
         */
        DsPermissionType: number
        /**
         * Format: int64
         * @description A Duration represents the elapsed time between two instants
         *     as an int64 nanosecond count. The representation limits the
         *     largest representable duration to approximately 290 years.
         */
        Duration: number
        /** EmailConfig configures notifications via mail. */
        EmailConfig: {
            auth_identity: string
            auth_password: components['schemas']['Secret']
            auth_password_file: string
            auth_secret: components['schemas']['Secret']
            auth_username: string
            from: string
            headers: {
                [key: string]: string
            }
            hello: string
            html: string
            require_tls: boolean
            send_resolved: boolean
            smarthost: components['schemas']['HostPort']
            text: string
            tls_config: components['schemas']['TLSConfig']
            /** @description Email address to notify. */
            to: string
        }
        EmailDTO: {
            recipient: string
            uid: string
        }
        /** @description EmbeddedContactPoint is the contact point type that is used
         *     by grafanas embedded alertmanager implementation. */
        EmbeddedContactPoint: {
            /** @example false */
            disableResolveMessage?: boolean
            /**
             * @description Name is used as grouping key in the UI. Contact points with the
             *     same name will be grouped in the UI.
             * @example webhook_1
             */
            name?: string
            readonly provenance?: string
            settings: components['schemas']['Json']
            /**
             * @example webhook
             * @enum {string}
             */
            type:
                | 'alertmanager'
                | 'dingding'
                | 'discord'
                | 'email'
                | 'googlechat'
                | 'kafka'
                | 'line'
                | 'opsgenie'
                | 'pagerduty'
                | 'pushover'
                | 'sensugo'
                | 'slack'
                | 'teams'
                | 'telegram'
                | 'threema'
                | 'victorops'
                | 'webhook'
                | 'wecom'
            /**
             * @description UID is the unique identifier of the contact point. The UID can be
             *     set by the user.
             * @example my_external_reference
             */
            uid?: string
        }
        /** @description Enum field config
         *     Vector values are used as lookup keys into the enum fields */
        EnumFieldConfig: {
            /** @description Color is the color value for a given index (empty is undefined) */
            color: string[]
            /** @description Description of the enum state */
            description: string[]
            /** @description Icon supports setting an icon for a given index value */
            icon: string[]
            /** @description Value is the string display value for a given index */
            text: string[]
        }
        ErrorResponseBody: {
            /** @description Error An optional detailed description of the actual error. Only included if running in developer mode. */
            error?: string
            /** @description a human readable version of the error */
            message: string
            /** @description Status An optional status to denote the cause of the error.
             *
             *     For example, a 412 Precondition Failed error may include additional information of why that error happened. */
            status?: string
        }
        /** ErrorType models the different API error types. */
        ErrorType: string
        /** @description EvalAlertConditionCommand is the command for evaluating a condition */
        EvalAlertConditionCommand: {
            condition: string
            data: components['schemas']['AlertQuery'][]
            /** Format: date-time */
            now: string
        }
        EvalQueriesPayload: {
            condition: string
            data: components['schemas']['AlertQuery'][]
            /** Format: date-time */
            now: string
        }
        EvalQueriesResponse: Record<string, never>
        /** @description This is an object constructed with the keys as the values of the enum VisType and the value being a bag of properties */
        ExplorePanelsState: unknown
        /**
         * ExtKeyUsage represents an extended set of actions that are valid for a given key.
         * Format: int64
         * @description Each of the ExtKeyUsage* constants define a unique action.
         */
        ExtKeyUsage: number
        ExtendedReceiver: {
            email_configs: components['schemas']['EmailConfig']
            grafana_managed_receiver: components['schemas']['PostableGrafanaReceiver']
            opsgenie_configs: components['schemas']['OpsGenieConfig']
            pagerduty_configs: components['schemas']['PagerdutyConfig']
            pushover_configs: components['schemas']['PushoverConfig']
            slack_configs: components['schemas']['SlackConfig']
            victorops_configs: components['schemas']['VictorOpsConfig']
            webhook_configs: components['schemas']['WebhookConfig']
            wechat_configs: components['schemas']['WechatConfig']
        }
        /** @description Extension represents the ASN.1 structure of the same name. See RFC
         *     5280, section 4.2. */
        Extension: {
            Critical: boolean
            Id: components['schemas']['ObjectIdentifier']
            Value: number[]
        }
        /** @description FailedUser holds the information of an user that failed */
        FailedUser: {
            Error: string
            Login: string
        }
        Failure: components['schemas']['ResponseDetails']
        /**
         * Field represents a typed column of data within a Frame.
         * @description A Field is essentially a slice of various types with extra properties and methods.
         *     See NewField() for supported types.
         *
         *     The slice data in the Field is a not exported, so methods on the Field are used to to manipulate its data.
         */
        Field: {
            config: components['schemas']['FieldConfig']
            labels: components['schemas']['FrameLabels']
            /** @description Name is default identifier of the field. The name does not have to be unique, but the combination
             *     of name and Labels should be unique for proper behavior in all situations. */
            name: string
        }
        /** FieldConfig represents the display properties for a Field. */
        FieldConfig: {
            /** @description Map values to a display color
             *     NOTE: this interface is under development in the frontend... so simple map for now */
            color: {
                [key: string]: unknown
            }
            /** @description Panel Specific Values */
            custom: {
                [key: string]: unknown
            }
            /** Format: uint16 */
            decimals: number
            /** @description Description is human readable field metadata */
            description: string
            /** @description DisplayName overrides Grafana default naming, should not be used from a data source */
            displayName: string
            /** @description DisplayNameFromDS overrides Grafana default naming strategy. */
            displayNameFromDS: string
            /** @description Filterable indicates if the Field's data can be filtered by additional calls. */
            filterable: boolean
            /**
             * Format: double
             * @description Interval indicates the expected regular step between values in the series.
             *     When an interval exists, consumers can identify "missing" values when the expected value is not present.
             *     The grafana timeseries visualization will render disconnected values when missing values are found it the time field.
             *     The interval uses the same units as the values.  For time.Time, this is defined in milliseconds.
             */
            interval: number
            /** @description The behavior when clicking on a result */
            links: components['schemas']['DataLink'][]
            mappings: components['schemas']['ValueMappings']
            max: components['schemas']['ConfFloat64']
            min: components['schemas']['ConfFloat64']
            /** @description Alternative to empty string */
            noValue: string
            /** @description Path is an explicit path to the field in the datasource. When the frame meta includes a path,
             *     this will default to `${frame.meta.path}/${field.name}
             *
             *     When defined, this value can be used as an identifier within the datasource scope, and
             *     may be used as an identifier to update values in a subsequent request */
            path: string
            thresholds: components['schemas']['ThresholdsConfig']
            type: components['schemas']['FieldTypeConfig']
            /** @description Numeric Options */
            unit: string
            /** @description Writeable indicates that the datasource knows how to update this value */
            writeable: boolean
        }
        /** @description FieldTypeConfig has type specific configs, only one should be active at a time */
        FieldTypeConfig: {
            enum: components['schemas']['EnumFieldConfig']
        }
        /** FindTagsResult is the result of a tags search. */
        FindTagsResult: {
            tags: components['schemas']['TagsDTO'][]
        }
        /**
         * FloatHistogram is similar to Histogram but uses float64 for all
         *     counts. Additionally, bucket counts are absolute and not deltas.
         * @description A FloatHistogram is needed by PromQL to handle operations that might result
         *     in fractional counts. Since the counts in a histogram are unlikely to be too
         *     large to be represented precisely by a float64, a FloatHistogram can also be
         *     used to represent a histogram with integer counts and thus serves as a more
         *     generalized representation.
         */
        FloatHistogram: {
            /**
             * Format: double
             * @description Total number of observations. Must be zero or positive.
             */
            Count: number
            CounterResetHint: components['schemas']['CounterResetHint']
            /** @description Holds the custom (usually upper) bounds for bucket definitions, otherwise nil.
             *     This slice is interned, to be treated as immutable and copied by reference.
             *     These numbers should be strictly increasing. This field is only used when the
             *     schema is for custom buckets, and the ZeroThreshold, ZeroCount, NegativeSpans
             *     and NegativeBuckets fields are not used in that case. */
            CustomValues: number[]
            /** @description Observation counts in buckets. Each represents an absolute count and
             *     must be zero or positive. */
            PositiveBuckets: number[]
            /** @description Spans for positive and negative buckets (see Span below). */
            PositiveSpans: components['schemas']['Span'][]
            /**
             * Format: int32
             * @description Currently valid schema numbers are -4 <= n <= 8 for exponential buckets.
             *     They are all for base-2 bucket schemas, where 1 is a bucket boundary in
             *     each case, and then each power of two is divided into 2^n logarithmic buckets.
             *     Or in other words, each bucket boundary is the previous boundary times
             *     2^(2^-n). Another valid schema number is -53 for custom buckets, defined by
             *     the CustomValues field.
             */
            Schema: number
            /**
             * Format: double
             * @description Sum of observations. This is also used as the stale marker.
             */
            Sum: number
            /**
             * Format: double
             * @description Observations falling into the zero bucket. Must be zero or positive.
             */
            ZeroCount: number
            /**
             * Format: double
             * @description Width of the zero bucket.
             */
            ZeroThreshold: number
        }
        Folder: {
            accessControl: components['schemas']['Metadata']
            canAdmin: boolean
            canDelete: boolean
            canEdit: boolean
            canSave: boolean
            /** Format: date-time */
            created: string
            createdBy: string
            hasAcl: boolean
            /**
             * Format: int64
             * @description Deprecated: use UID instead
             */
            id: number
            managedBy: components['schemas']['ManagerKind']
            /** Format: int64 */
            orgId: number
            /** @description only used if nested folders are enabled */
            parentUid: string
            /** @description the parent folders starting from the root going down */
            parents: components['schemas']['Folder'][]
            title: string
            uid: string
            /** Format: date-time */
            updated: string
            updatedBy: string
            url: string
            /** Format: int64 */
            version: number
        }
        FolderSearchHit: {
            /** Format: int64 */
            id: number
            managedBy: components['schemas']['ManagerKind']
            parentUid: string
            title: string
            uid: string
        }
        ForbiddenError: {
            body: components['schemas']['PublicError']
        }
        /**
         * Frame is a columnar data structure where each column is a Field.
         * @description Each Field is well typed by its FieldType and supports optional Labels.
         *
         *     A Frame is a general data container for Grafana. A Frame can be table data
         *     or time series data depending on its content and field types.
         */
        Frame: {
            /** @description Fields are the columns of a frame.
             *     All Fields must be of the same the length when marshalling the Frame for transmission.
             *     There should be no `nil` entries in the Fields slice (making them pointers was a mistake). */
            Fields: components['schemas']['Field'][]
            Meta: components['schemas']['FrameMeta']
            /** @description Name is used in some Grafana visualizations. */
            Name: string
            /** @description RefID is a property that can be set to match a Frame to its originating query. */
            RefID: string
        }
        /** @description Labels are used to add metadata to an object.  The JSON will always be sorted keys */
        FrameLabels: {
            [key: string]: string
        }
        /**
         * FrameMeta matches:
         * @description https://github.com/grafana/grafana/blob/master/packages/grafana-data/src/types/data.ts#L11
         *     NOTE -- in javascript this can accept any `[key: string]: any;` however
         *     this interface only exposes the values we want to be exposed
         */
        FrameMeta: {
            /** @description Channel is the path to a stream in grafana live that has real-time updates for this data. */
            channel: string
            /** @description Custom datasource specific values. */
            custom: unknown
            dataTopic: components['schemas']['DataTopic']
            /** @description ExecutedQueryString is the raw query sent to the underlying system. All macros and templating
             *     have been applied.  When metadata contains this value, it will be shown in the query inspector. */
            executedQueryString: string
            /** @description Notices provide additional information about the data in the Frame that
             *     Grafana can display to the user in the user interface. */
            notices: components['schemas']['Notice'][]
            /** @description Path is a browsable path on the datasource. */
            path: string
            /** @description PathSeparator defines the separator pattern to decode a hierarchy. The default separator is '/'. */
            pathSeparator: string
            /** @description PreferredVisualizationPluginId sets the panel plugin id to use to render the data when using Explore. If
             *     the plugin cannot be found will fall back to PreferredVisualization. */
            preferredVisualisationPluginId: string
            preferredVisualisationType: components['schemas']['VisType']
            /** @description Stats is an array of query result statistics. */
            stats: components['schemas']['QueryStat'][]
            type: components['schemas']['FrameType']
            typeVersion: components['schemas']['FrameTypeVersion']
            /**
             * @description Array of field indices which values create a unique id for each row. Ideally this should be globally unique ID
             *     but that isn't guarantied. Should help with keeping track and deduplicating rows in visualizations, especially
             *     with streaming data with frequent updates.
             * @example TraceID in Tempo, table name + primary key in SQL
             */
            uniqueRowIdFields: number[]
        }
        /** @description A FrameType string, when present in a frame's metadata, asserts that the
         *     frame's structure conforms to the FrameType's specification.
         *     This property is currently optional, so FrameType may be FrameTypeUnknown even if the properties of
         *     the Frame correspond to a defined FrameType.
         *     +enum */
        FrameType: string
        /** FrameType is a 2 number version (Major / Minor). */
        FrameTypeVersion: number[]
        /**
         * Frames is a slice of Frame pointers.
         * @description It is the main data container within a backend.DataResponse.
         *     There should be no `nil` entries in the Frames slice (making them pointers was a mistake).
         */
        Frames: components['schemas']['Frame'][]
        GetAccessTokenResponseDTO: {
            createdAt: string
            displayName: string
            expiresAt: string
            firstUsedAt: string
            id: string
            lastUsedAt: string
        }
        /** GetAnnotationTagsResponse is a response struct for FindTagsResult. */
        GetAnnotationTagsResponse: {
            result: components['schemas']['FindTagsResult']
        }
        /** Get home dashboard response. */
        GetHomeDashboardResponse: {
            dashboard?: components['schemas']['Json']
            meta?: components['schemas']['DashboardMeta']
        } & {
            redirectUri?: string
        }
        GetSnapshotResponseDTO: {
            /** Format: date-time */
            created: string
            /** Format: date-time */
            finished: string
            results: components['schemas']['MigrateDataResponseItemDTO'][]
            sessionUid: string
            stats: components['schemas']['SnapshotResourceStats']
            /** @enum {string} */
            status:
                | 'INITIALIZING'
                | 'CREATING'
                | 'PENDING_UPLOAD'
                | 'UPLOADING'
                | 'PENDING_PROCESSING'
                | 'PROCESSING'
                | 'FINISHED'
                | 'CANCELED'
                | 'ERROR'
                | 'UNKNOWN'
            uid: string
        }
        GettableAlertmanagers: {
            data: components['schemas']['AlertManagersResult']
            status: string
        }
        GettableApiAlertingConfig: {
            global: components['schemas']['GlobalConfig']
            inhibit_rules: components['schemas']['InhibitRule'][]
            muteTimeProvenances: {
                [key: string]: components['schemas']['Provenance']
            }
            /** @description MuteTimeIntervals is deprecated and will be removed before Alertmanager 1.0. */
            mute_time_intervals: components['schemas']['MuteTimeInterval'][]
            /** @description Override with our superset receiver type */
            receivers: components['schemas']['GettableApiReceiver'][]
            route: components['schemas']['Route']
            templates: string[]
            time_intervals: components['schemas']['TimeInterval'][]
        }
        GettableApiReceiver: {
            discord_configs: components['schemas']['DiscordConfig'][]
            email_configs: components['schemas']['EmailConfig'][]
            grafana_managed_receiver_configs: components['schemas']['GettableGrafanaReceiver'][]
            jira_configs: components['schemas']['JiraConfig'][]
            msteams_configs: components['schemas']['MSTeamsConfig'][]
            /** @description A unique identifier for this receiver. */
            name: string
            opsgenie_configs: components['schemas']['OpsGenieConfig'][]
            pagerduty_configs: components['schemas']['PagerdutyConfig'][]
            pushover_configs: components['schemas']['PushoverConfig'][]
            slack_configs: components['schemas']['SlackConfig'][]
            sns_configs: components['schemas']['SNSConfig'][]
            telegram_configs: components['schemas']['TelegramConfig'][]
            victorops_configs: components['schemas']['VictorOpsConfig'][]
            webex_configs: components['schemas']['WebexConfig'][]
            webhook_configs: components['schemas']['WebhookConfig'][]
            wechat_configs: components['schemas']['WechatConfig'][]
        }
        GettableExtendedRuleNode: {
            alert: string
            annotations: {
                [key: string]: string
            }
            expr: string
            for: string
            grafana_alert: components['schemas']['GettableGrafanaRule']
            keep_firing_for: string
            labels: {
                [key: string]: string
            }
            record: string
        }
        GettableGrafanaReceiver: {
            disableResolveMessage: boolean
            name: string
            provenance: components['schemas']['Provenance']
            secureFields: {
                [key: string]: boolean
            }
            settings: components['schemas']['RawMessage']
            type: string
            uid: string
        }
        GettableGrafanaReceivers: {
            grafana_managed_receiver_configs: components['schemas']['GettableGrafanaReceiver'][]
        }
        GettableGrafanaRule: {
            condition: string
            data: components['schemas']['AlertQuery'][]
            /** @enum {string} */
            exec_err_state: 'OK' | 'Alerting' | 'Error'
            guid: string
            /** Format: int64 */
            intervalSeconds: number
            is_paused: boolean
            metadata: components['schemas']['AlertRuleMetadata']
            /** Format: int64 */
            missing_series_evals_to_resolve: number
            namespace_uid: string
            /** @enum {string} */
            no_data_state: 'Alerting' | 'NoData' | 'OK'
            notification_settings: components['schemas']['AlertRuleNotificationSettings']
            provenance: components['schemas']['Provenance']
            record: components['schemas']['Record']
            rule_group: string
            title: string
            uid: string
            /** Format: date-time */
            updated: string
            updated_by: components['schemas']['UserInfo']
            /** Format: int64 */
            version: number
        }
        GettableHistoricUserConfig: {
            alertmanager_config: components['schemas']['GettableApiAlertingConfig']
            /** Format: int64 */
            id: number
            /** Format: date-time */
            last_applied: string
            template_file_provenances: {
                [key: string]: components['schemas']['Provenance']
            }
            template_files: {
                [key: string]: string
            }
        }
        GettableNGalertConfig: {
            /** @enum {string} */
            alertmanagersChoice: 'all' | 'internal' | 'external'
        }
        GettableRuleGroupConfig: {
            align_evaluation_time_on_interval: boolean
            evaluation_delay: string
            interval: components['schemas']['Duration']
            /** Format: int64 */
            limit: number
            name: string
            query_offset: string
            rules: components['schemas']['GettableExtendedRuleNode'][]
            source_tenants: string[]
        }
        GettableRuleVersions: components['schemas']['GettableExtendedRuleNode'][]
        GettableStatus: {
            cluster: components['schemas']['clusterStatus']
            config: components['schemas']['PostableApiAlertingConfig']
            /**
             * Format: date-time
             * @description uptime
             */
            uptime: string
            versionInfo: components['schemas']['versionInfo']
        }
        GettableUserConfig: {
            alertmanager_config: components['schemas']['GettableApiAlertingConfig']
            template_file_provenances: {
                [key: string]: components['schemas']['Provenance']
            }
            template_files: {
                [key: string]: string
            }
        }
        /** @description GlobalConfig defines configuration parameters that are valid globally
         *     unless overwritten. */
        GlobalConfig: {
            http_config: components['schemas']['HTTPClientConfig']
            jira_api_url: components['schemas']['URL']
            opsgenie_api_key: components['schemas']['Secret']
            opsgenie_api_key_file: string
            opsgenie_api_url: components['schemas']['URL']
            pagerduty_url: components['schemas']['URL']
            resolve_timeout: components['schemas']['Duration']
            slack_api_url: components['schemas']['SecretURL']
            slack_api_url_file: string
            smtp_auth_identity: string
            smtp_auth_password: components['schemas']['Secret']
            smtp_auth_password_file: string
            smtp_auth_secret: components['schemas']['Secret']
            smtp_auth_username: string
            smtp_from: string
            smtp_hello: string
            smtp_require_tls: boolean
            smtp_smarthost: components['schemas']['HostPort']
            smtp_tls_config: components['schemas']['TLSConfig']
            telegram_api_url: components['schemas']['URL']
            victorops_api_key: components['schemas']['Secret']
            victorops_api_key_file: string
            victorops_api_url: components['schemas']['URL']
            webex_api_url: components['schemas']['URL']
            wechat_api_corp_id: string
            wechat_api_secret: components['schemas']['Secret']
            wechat_api_url: components['schemas']['URL']
        }
        Group: {
            groupID: string
            mappings: unknown
        }
        GroupAttributes: {
            roles: string[]
        }
        /** HTTPClientConfig configures an HTTP client. */
        HTTPClientConfig: {
            authorization: components['schemas']['Authorization']
            basic_auth: components['schemas']['BasicAuth']
            bearer_token: components['schemas']['Secret']
            /** @description The bearer token file for the targets. Deprecated in favour of
             *     Authorization.CredentialsFile. */
            bearer_token_file: string
            /** @description EnableHTTP2 specifies whether the client should configure HTTP2.
             *     The omitempty flag is not set, because it would be hidden from the
             *     marshalled configuration when set to false. */
            enable_http2: boolean
            /** @description FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
             *     The omitempty flag is not set, because it would be hidden from the
             *     marshalled configuration when set to false. */
            follow_redirects: boolean
            http_headers: components['schemas']['Headers']
            /** @description NoProxy contains addresses that should not use a proxy. */
            no_proxy: string
            oauth2: components['schemas']['OAuth2']
            proxy_connect_header: components['schemas']['ProxyHeader']
            /** @description ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function
             *     to determine proxies. */
            proxy_from_environment: boolean
            proxy_url: components['schemas']['URL']
            tls_config: components['schemas']['TLSConfig']
        }
        /** Header represents the configuration for a single HTTP header. */
        Header: {
            files: string[]
            secrets: components['schemas']['Secret'][]
            values: string[]
        }
        /** Headers represents the configuration for HTTP headers. */
        Headers: {
            Headers: {
                [key: string]: components['schemas']['Header']
            }
        }
        Hit: {
            /** Format: int64 */
            folderId: number
            folderTitle: string
            folderUid: string
            folderUrl: string
            /** Format: int64 */
            id: number
            isDeleted: boolean
            isStarred: boolean
            /** Format: int64 */
            orgId: number
            /** Format: date-time */
            permanentlyDeleteDate: string
            slug: string
            /** Format: int64 */
            sortMeta: number
            sortMetaName: string
            tags: string[]
            title: string
            type: components['schemas']['HitType']
            uid: string
            uri: string
            url: string
        }
        HitList: components['schemas']['Hit'][]
        HitType: string
        /** HostPort represents a "host:port" network address. */
        HostPort: {
            Host: string
            Port: string
        }
        /**
         * An IPMask is a bitmask that can be used to manipulate
         *     IP addresses for IP addressing and routing.
         * @description See type [IPNet] and func [ParseCIDR] for details.
         */
        IPMask: number[]
        /** An IPNet represents an IP network. */
        IPNet: {
            IP: string
            Mask: components['schemas']['IPMask']
        }
        /** ImportDashboardInput definition of input parameters when importing a dashboard. */
        ImportDashboardInput: {
            name: string
            pluginId: string
            type: string
            value: string
        }
        /** ImportDashboardRequest request object for importing a dashboard. */
        ImportDashboardRequest: {
            dashboard: components['schemas']['Json']
            /**
             * Format: int64
             * @description Deprecated: use FolderUID instead
             */
            folderId: number
            folderUid: string
            inputs: components['schemas']['ImportDashboardInput'][]
            overwrite: boolean
            path: string
            pluginId: string
        }
        /** ImportDashboardResponse response object returned when importing a dashboard. */
        ImportDashboardResponse: {
            /** Format: int64 */
            dashboardId: number
            description: string
            /**
             * Format: int64
             * @description Deprecated: use FolderUID instead
             */
            folderId: number
            folderUid: string
            imported: boolean
            /** Format: int64 */
            importedRevision: number
            importedUri: string
            importedUrl: string
            path: string
            pluginId: string
            removed: boolean
            /** Format: int64 */
            revision: number
            slug: string
            title: string
            uid: string
        }
        /** @description InhibitRule defines an inhibition rule that mutes alerts that match the
         *     target labels if an alert matching the source labels exists.
         *     Both alerts have to have a set of labels being equal. */
        InhibitRule: {
            equal: components['schemas']['LabelNames']
            /** @description SourceMatch defines a set of labels that have to equal the given
             *     value for source alerts. Deprecated. Remove before v1.0 release. */
            source_match: {
                [key: string]: string
            }
            source_match_re: components['schemas']['MatchRegexps']
            source_matchers: components['schemas']['Matchers']
            /** @description TargetMatch defines a set of labels that have to equal the given
             *     value for target alerts. Deprecated. Remove before v1.0 release. */
            target_match: {
                [key: string]: string
            }
            target_match_re: components['schemas']['MatchRegexps']
            target_matchers: components['schemas']['Matchers']
        }
        /**
         * InspectType is a type for the Inspect property of a Notice.
         * Format: int64
         */
        InspectType: number
        /** @description InternalDataLink definition to allow Explore links to be constructed in the backend */
        InternalDataLink: {
            datasourceName: string
            datasourceUid: string
            panelsState: components['schemas']['ExplorePanelsState']
            query: unknown
            timeRange: components['schemas']['TimeRange']
            transformations: components['schemas']['LinkTransformationConfig'][]
        }
        /** @description JSONWebKey represents a public or private key in JWK format. It can be
         *     marshaled into JSON and unmarshaled from JSON. */
        JSONWebKey: {
            /** @description Key algorithm, parsed from `alg` header. */
            Algorithm: string
            /** @description X.509 certificate thumbprint (SHA-1), parsed from `x5t` header. */
            CertificateThumbprintSHA1: number[]
            /** @description X.509 certificate thumbprint (SHA-256), parsed from `x5t#S256` header. */
            CertificateThumbprintSHA256: number[]
            /** @description X.509 certificate chain, parsed from `x5c` header. */
            Certificates: components['schemas']['Certificate'][]
            CertificatesURL: components['schemas']['URL']
            /** @description Key is the Go in-memory representation of this key. It must have one
             *     of these types:
             *     ed25519.PublicKey
             *     ed25519.PrivateKey
             *     ecdsa.PublicKey
             *     ecdsa.PrivateKey
             *     rsa.PublicKey
             *     rsa.PrivateKey
             *     []byte (a symmetric key)
             *
             *     When marshaling this JSONWebKey into JSON, the "kty" header parameter
             *     will be automatically set based on the type of this field. */
            Key: unknown
            /** @description Key identifier, parsed from `kid` header. */
            KeyID: string
            /** @description Key use, parsed from `use` header. */
            Use: string
        }
        JiraConfig: {
            api_url: components['schemas']['URL']
            custom_fields: {
                [key: string]: unknown
            }
            description: string
            http_config: components['schemas']['HTTPClientConfig']
            issue_type: string
            labels: string[]
            priority: string
            project: string
            reopen_duration: components['schemas']['Duration']
            reopen_transition: string
            resolve_transition: string
            send_resolved: boolean
            summary: string
            wont_fix_resolution: string
        }
        Json: Record<string, never>
        /**
         * Format: int64
         * @description KeyUsage represents the set of actions that are valid for a given key. It's
         *     a bitmap of the KeyUsage* constants.
         */
        KeyUsage: number
        /** Label is a key/value pair of strings. */
        Label: {
            Name: string
        }
        /** @description A LabelName is a key for a LabelSet or Metric.  It has a value associated
         *     therewith. */
        LabelName: string
        /** LabelNames is a sortable LabelName slice. In implements sort.Interface. */
        LabelNames: components['schemas']['LabelName'][]
        /** @description A LabelSet is a collection of LabelName and LabelValue pairs.  The LabelSet
         *     may be fully-qualified down to the point where it may resolve to a single
         *     Metric in the data store or not.  All operations that occur within the realm
         *     of a LabelSet can emit a vector of Metric entities to which the LabelSet may
         *     match. */
        LabelSet: {
            [key: string]: components['schemas']['LabelValue']
        }
        /** A LabelValue is an associated value for a LabelName. */
        LabelValue: string
        /** @description Labels is a sorted set of labels. Order has to be guaranteed upon
         *     instantiation. */
        Labels: components['schemas']['Label'][]
        /** LibraryElementArrayResponse is a response struct for an array of LibraryElementDTO. */
        LibraryElementArrayResponse: {
            result: components['schemas']['LibraryElementDTO'][]
        }
        /** LibraryElementConnectionDTO is the frontend DTO for element connections. */
        LibraryElementConnectionDTO: {
            /** Format: int64 */
            connectionId: number
            connectionUid: string
            /** Format: date-time */
            created: string
            createdBy: components['schemas']['LibraryElementDTOMetaUser']
            /** Format: int64 */
            elementId: number
            /** Format: int64 */
            id: number
            /** Format: int64 */
            kind: number
        }
        /** LibraryElementConnectionsResponse is a response struct for an array of LibraryElementConnectionDTO. */
        LibraryElementConnectionsResponse: {
            result: components['schemas']['LibraryElementConnectionDTO'][]
        }
        /** LibraryElementDTO is the frontend DTO for entities. */
        LibraryElementDTO: {
            description: string
            /**
             * Format: int64
             * @description Deprecated: use FolderUID instead
             */
            folderId: number
            folderUid: string
            /** Format: int64 */
            id: number
            /** Format: int64 */
            kind: number
            meta: components['schemas']['LibraryElementDTOMeta']
            model: Record<string, never>
            name: string
            /** Format: int64 */
            orgId: number
            /** Format: int64 */
            schemaVersion: number
            type: string
            uid: string
            /** Format: int64 */
            version: number
        }
        /** LibraryElementDTOMeta is the meta information for LibraryElementDTO. */
        LibraryElementDTOMeta: {
            /** Format: int64 */
            connectedDashboards: number
            /** Format: date-time */
            created: string
            createdBy: components['schemas']['LibraryElementDTOMetaUser']
            folderName: string
            folderUid: string
            /** Format: date-time */
            updated: string
            updatedBy: components['schemas']['LibraryElementDTOMetaUser']
        }
        LibraryElementDTOMetaUser: {
            avatarUrl: string
            /** Format: int64 */
            id: number
            name: string
        }
        /** LibraryElementResponse is a response struct for LibraryElementDTO. */
        LibraryElementResponse: {
            result: components['schemas']['LibraryElementDTO']
        }
        /** LibraryElementSearchResponse is a response struct for LibraryElementSearchResult. */
        LibraryElementSearchResponse: {
            result: components['schemas']['LibraryElementSearchResult']
        }
        /** LibraryElementSearchResult is the search result for entities. */
        LibraryElementSearchResult: {
            elements: components['schemas']['LibraryElementDTO'][]
            /** Format: int64 */
            page: number
            /** Format: int64 */
            perPage: number
            /** Format: int64 */
            totalCount: number
        }
        LinkTransformationConfig: {
            expression: string
            field: string
            mapValue: string
            type: components['schemas']['SupportedTransformationTypes']
        }
        MSTeamsConfig: {
            http_config: components['schemas']['HTTPClientConfig']
            send_resolved: boolean
            summary: string
            text: string
            title: string
            webhook_url: components['schemas']['SecretURL']
            webhook_url_file: string
        }
        /**
         * ManagerKind is the type of manager, which is responsible for managing the resource.
         * @description It can be a user or a tool or a generic API client.
         *     +enum
         */
        ManagerKind: string
        MassDeleteAnnotationsCmd: {
            /** Format: int64 */
            annotationId: number
            /** Format: int64 */
            dashboardId: number
            dashboardUID: string
            /** Format: int64 */
            panelId: number
        }
        /** MatchRegexps represents a map of Regexp. */
        MatchRegexps: {
            [key: string]: string
        }
        /**
         * MatchType is an enum for label matching types.
         * Format: int64
         */
        MatchType: number
        /** Matcher models the matching of a label. */
        Matcher: {
            Name: string
            Type: components['schemas']['MatchType']
            Value: string
        }
        /** @description Matchers is a slice of Matchers that is sortable, implements Stringer, and
         *     provides a Matches method to match a LabelSet against all Matchers in the
         *     slice. Note that some users of Matchers might require it to be sorted. */
        Matchers: components['schemas']['Matcher'][]
        /** @description Metadata contains user accesses for a given resource
         *     Ex: map[string]bool{"create":true, "delete": true} */
        Metadata: {
            [key: string]: boolean
        }
        MetricRequest: {
            debug?: boolean
            /**
             * @description From Start time in epoch timestamps in milliseconds or relative using Grafana time units.
             * @example now-1h
             */
            from: string
            /**
             * @description queries.refId – Specifies an identifier of the query. Is optional and default to “A”.
             *     queries.datasourceId – Specifies the data source to be queried. Each query in the request must have an unique datasourceId.
             *     queries.maxDataPoints - Species maximum amount of data points that dashboard panel can render. Is optional and default to 100.
             *     queries.intervalMs - Specifies the time interval in milliseconds of time series. Is optional and defaults to 1000.
             * @example [
             *       {
             *         "datasource": {
             *           "uid": "PD8C576611E62080A"
             *         },
             *         "format": "table",
             *         "intervalMs": 86400000,
             *         "maxDataPoints": 1092,
             *         "rawSql": "SELECT 1 as valueOne, 2 as valueTwo",
             *         "refId": "A"
             *       }
             *     ]
             */
            queries: components['schemas']['Json'][]
            /**
             * @description To End time in epoch timestamps in milliseconds or relative using Grafana time units.
             * @example now
             */
            to: string
        }
        MigrateDataResponseDTO: {
            items: components['schemas']['MigrateDataResponseItemDTO'][]
            uid: string
        }
        MigrateDataResponseItemDTO: {
            /** @enum {string} */
            errorCode?:
                | 'DATASOURCE_NAME_CONFLICT'
                | 'DATASOURCE_INVALID_URL'
                | 'DATASOURCE_ALREADY_MANAGED'
                | 'FOLDER_NAME_CONFLICT'
                | 'DASHBOARD_ALREADY_MANAGED'
                | 'LIBRARY_ELEMENT_NAME_CONFLICT'
                | 'UNSUPPORTED_DATA_TYPE'
                | 'RESOURCE_CONFLICT'
                | 'UNEXPECTED_STATUS_CODE'
                | 'INTERNAL_SERVICE_ERROR'
                | 'GENERIC_ERROR'
            message?: string
            name?: string
            parentName?: string
            refId: string
            /** @enum {string} */
            status: 'OK' | 'WARNING' | 'ERROR' | 'PENDING' | 'UNKNOWN'
            /** @enum {string} */
            type:
                | 'DASHBOARD'
                | 'DATASOURCE'
                | 'FOLDER'
                | 'LIBRARY_ELEMENT'
                | 'ALERT_RULE'
                | 'ALERT_RULE_GROUP'
                | 'CONTACT_POINT'
                | 'NOTIFICATION_POLICY'
                | 'NOTIFICATION_TEMPLATE'
                | 'MUTE_TIMING'
                | 'PLUGIN'
        }
        MigrateDataResponseListDTO: {
            uid: string
        }
        /** @description MoveFolderCommand captures the information required by the folder service
         *     to move a folder. */
        MoveFolderCommand: {
            parentUid: string
        }
        MultiStatus: Record<string, never>
        /** MuteTimeInterval represents a named set of time intervals for which a route should be muted. */
        MuteTimeInterval: {
            name: string
            time_intervals: components['schemas']['TimeInterval'][]
        }
        MuteTimeIntervalExport: {
            name: string
            /** Format: int64 */
            orgId: number
            time_intervals: components['schemas']['TimeInterval'][]
        }
        MuteTimings: components['schemas']['MuteTimeInterval'][]
        /** @description Name represents an X.509 distinguished name. This only includes the common
         *     elements of a DN. Note that Name is only an approximation of the X.509
         *     structure. If an accurate representation is needed, asn1.Unmarshal the raw
         *     subject or issuer as an [RDNSequence]. */
        Name: {
            Country: string[]
            /** @description ExtraNames contains attributes to be copied, raw, into any marshaled
             *     distinguished names. Values override any attributes with the same OID.
             *     The ExtraNames field is not populated when parsing, see Names. */
            ExtraNames: components['schemas']['AttributeTypeAndValue'][]
            Locality: string[]
            /** @description Names contains all parsed attributes. When parsing distinguished names,
             *     this can be used to extract non-standard attributes that are not parsed
             *     by this package. When marshaling to RDNSequences, the Names field is
             *     ignored, see ExtraNames. */
            Names: components['schemas']['AttributeTypeAndValue'][]
            SerialNumber: string
            StreetAddress: string[]
        }
        NamespaceConfigResponse: {
            [key: string]: components['schemas']['GettableRuleGroupConfig'][]
        }
        NavbarPreference: {
            bookmarkUrls: string[]
        }
        NewApiKeyResult: {
            /**
             * Format: int64
             * @example 1
             */
            id: number
            /** @example glsa_yscW25imSKJIuav8zF37RZmnbiDvB05G_fcaaf58a */
            key: string
            /** @example grafana */
            name: string
        }
        NotFound: Record<string, never>
        /** Notice provides a structure for presenting notifications in Grafana's user interface. */
        Notice: {
            inspect: components['schemas']['InspectType']
            /** @description Link is an optional link for display in the user interface and can be an
             *     absolute URL or a path relative to Grafana's root url. */
            link: string
            severity: components['schemas']['NoticeSeverity']
            /** @description Text is freeform descriptive text for the notice. */
            text: string
        }
        /**
         * NoticeSeverity is a type for the Severity property of a Notice.
         * Format: int64
         */
        NoticeSeverity: number
        /** NotificationPolicyExport is the provisioned file export of alerting.NotificiationPolicyV1. */
        NotificationPolicyExport: {
            continue: boolean
            group_by: string[]
            group_interval: string
            group_wait: string
            /** @description Deprecated. Remove before v1.0 release. */
            match: {
                [key: string]: string
            }
            match_re: components['schemas']['MatchRegexps']
            matchers: components['schemas']['Matchers']
            mute_time_intervals: string[]
            object_matchers: components['schemas']['ObjectMatchers']
            /** Format: int64 */
            orgId: number
            receiver: string
            repeat_interval: string
            routes: components['schemas']['RouteExport'][]
        }
        NotificationTemplate: {
            name: string
            provenance: components['schemas']['Provenance']
            template: string
            version: string
        }
        NotificationTemplateContent: {
            template: string
            version: string
        }
        NotificationTemplates: components['schemas']['NotificationTemplate'][]
        /** NotifierConfig contains base options common across all notifier configurations. */
        NotifierConfig: {
            send_resolved: boolean
        }
        /** OAuth2 is the oauth2 client configuration. */
        OAuth2: {
            TLSConfig: components['schemas']['TLSConfig']
            client_id: string
            client_secret: components['schemas']['Secret']
            client_secret_file: string
            /** @description ClientSecretRef is the name of the secret within the secret manager to use as the client
             *     secret. */
            client_secret_ref: string
            endpoint_params: {
                [key: string]: string
            }
            /** @description NoProxy contains addresses that should not use a proxy. */
            no_proxy: string
            proxy_connect_header: components['schemas']['ProxyHeader']
            /** @description ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function
             *     to determine proxies. */
            proxy_from_environment: boolean
            proxy_url: components['schemas']['URL']
            scopes: string[]
            token_url: string
        }
        /** An ObjectIdentifier represents an ASN.1 OBJECT IDENTIFIER. */
        ObjectIdentifier: number[]
        /** ObjectMatcher is a matcher that can be used to filter alerts. */
        ObjectMatcher: string[]
        /** ObjectMatchers is a list of matchers that can be used to filter alerts. */
        ObjectMatchers: components['schemas']['ObjectMatcher'][]
        /** OpsGenieConfig configures notifications via OpsGenie. */
        OpsGenieConfig: {
            actions: string
            api_key: components['schemas']['Secret']
            api_key_file: string
            api_url: components['schemas']['URL']
            description: string
            details: {
                [key: string]: string
            }
            entity: string
            http_config: components['schemas']['HTTPClientConfig']
            message: string
            note: string
            priority: string
            responders: components['schemas']['OpsGenieConfigResponder'][]
            send_resolved: boolean
            source: string
            tags: string
            update_alerts: boolean
        }
        OpsGenieConfigResponder: {
            /** @description One of those 3 should be filled. */
            id: string
            name: string
            /** @description team, user, escalation, schedule etc. */
            type: string
            username: string
        }
        OrgDTO: {
            /** Format: int64 */
            id: number
            name: string
        }
        OrgDetailsDTO: {
            address: components['schemas']['Address']
            /** Format: int64 */
            id: number
            name: string
        }
        OrgUserDTO: {
            accessControl: {
                [key: string]: boolean
            }
            authLabels: string[]
            avatarUrl: string
            email: string
            isDisabled: boolean
            isExternallySynced: boolean
            isProvisioned: boolean
            /** Format: date-time */
            lastSeenAt: string
            lastSeenAtAge: string
            login: string
            name: string
            /** Format: int64 */
            orgId: number
            role: string
            uid: string
            /** Format: int64 */
            userId: number
        }
        /** PagerdutyConfig configures notifications via PagerDuty. */
        PagerdutyConfig: {
            class: string
            client: string
            client_url: string
            component: string
            description: string
            details: {
                [key: string]: string
            }
            group: string
            http_config: components['schemas']['HTTPClientConfig']
            images: components['schemas']['PagerdutyImage'][]
            links: components['schemas']['PagerdutyLink'][]
            routing_key: components['schemas']['Secret']
            routing_key_file: string
            send_resolved: boolean
            service_key: components['schemas']['Secret']
            service_key_file: string
            severity: string
            source: string
            url: components['schemas']['URL']
        }
        /** PagerdutyImage is an image. */
        PagerdutyImage: {
            alt: string
            href: string
            src: string
        }
        /** PagerdutyLink is a link. */
        PagerdutyLink: {
            href: string
            text: string
        }
        Password: string
        PatchAnnotationsCmd: {
            data: components['schemas']['Json']
            /** Format: int64 */
            id: number
            tags: string[]
            text: string
            /** Format: int64 */
            time: number
            /** Format: int64 */
            timeEnd: number
        }
        /** @description PatchLibraryElementCommand is the command for patching a LibraryElement */
        PatchLibraryElementCommand: {
            /**
             * Format: int64
             * @description ID of the folder where the library element is stored.
             *
             *     Deprecated: use FolderUID instead
             */
            folderId: number
            /** @description UID of the folder where the library element is stored. */
            folderUid: string
            /**
             * Format: int64
             * @description Kind of element to create, Use 1 for library panels or 2 for c.
             *     Description:
             *     1 - library panels
             *     2 - library variables
             * @enum {integer}
             */
            kind: 1 | 2
            /** @description The JSON model for the library element. */
            model: Record<string, never>
            /** @description Name of the library element. */
            name: string
            uid: string
            /**
             * Format: int64
             * @description Version of the library element you are updating.
             */
            version: number
        }
        PatchPrefsCmd: {
            cookies: components['schemas']['CookieType'][]
            /**
             * Format: int64
             * @description The numerical :id of a favorited dashboard
             * @default 0
             */
            homeDashboardId: number
            homeDashboardUID: string
            language: string
            locale: string
            navbar: components['schemas']['NavbarPreference']
            queryHistory: components['schemas']['QueryHistoryPreference']
            /** @enum {string} */
            theme: 'light' | 'dark'
            /** @enum {string} */
            timezone: 'utc' | 'browser'
            weekStart: string
        }
        /** @description PatchQueryCommentInQueryHistoryCommand is the command for updating comment for query in query history */
        PatchQueryCommentInQueryHistoryCommand: {
            /** @description Updated comment */
            comment: string
        }
        /** Permission is the model for access control permissions. */
        Permission: {
            action: string
            /** Format: date-time */
            created: string
            scope: string
            /** Format: date-time */
            updated: string
        }
        PermissionDenied: Record<string, never>
        /** Format: int64 */
        PermissionType: number
        /** @description Playlist model */
        Playlist: {
            /** Format: int64 */
            id: number
            interval: string
            name: string
            uid: string
        }
        PlaylistDTO: {
            /** @description Interval sets the time between switching views in a playlist. */
            interval: string
            /** @description The ordered list of items that the playlist will iterate over. */
            items: components['schemas']['PlaylistItemDTO'][]
            /** @description Name of the playlist. */
            name: string
            /** @description Unique playlist identifier. Generated on creation, either by the
             *     creator of the playlist of by the application. */
            uid: string
        }
        PlaylistDashboard: {
            /** Format: int64 */
            id: number
            /** Format: int64 */
            order: number
            slug: string
            title: string
            uri: string
            url: string
        }
        PlaylistDashboardsSlice: components['schemas']['PlaylistDashboard'][]
        PlaylistItem: {
            /** Format: int64 */
            Id: number
            /** Format: int64 */
            PlaylistId: number
            /** Format: int64 */
            order: number
            title: string
            type: string
            value: string
        }
        PlaylistItemDTO: {
            /** @description Title is an unused property -- it will be removed in the future */
            title: string
            /** @description Type of the item. */
            type: string
            /** @description Value depends on type and describes the playlist item.
             *
             *     dashboard_by_id: The value is an internal numerical identifier set by Grafana. This
             *     is not portable as the numerical identifier is non-deterministic between different instances.
             *     Will be replaced by dashboard_by_uid in the future. (deprecated)
             *     dashboard_by_tag: The value is a tag which is set on any number of dashboards. All
             *     dashboards behind the tag will be added to the playlist.
             *     dashboard_by_uid: The value is the dashboard UID */
            value: string
        }
        Playlists: components['schemas']['Playlist'][]
        /** PolicyMapping represents a policy mapping entry in the policyMappings extension. */
        PolicyMapping: {
            /** @description IssuerDomainPolicy contains a policy OID the issuing certificate considers
             *     equivalent to SubjectDomainPolicy in the subject certificate. */
            IssuerDomainPolicy: string
            /** @description SubjectDomainPolicy contains a OID the issuing certificate considers
             *     equivalent to IssuerDomainPolicy in the subject certificate. */
            SubjectDomainPolicy: string
        }
        PostAnnotationsCmd: {
            /** Format: int64 */
            dashboardId?: number
            dashboardUID?: string
            data?: components['schemas']['Json']
            /** Format: int64 */
            panelId?: number
            tags?: string[]
            text: string
            /** Format: int64 */
            time?: number
            /** Format: int64 */
            timeEnd?: number
        }
        PostGraphiteAnnotationsCmd: {
            data: string
            tags: unknown
            what: string
            /** Format: int64 */
            when: number
        }
        /** @description nolint:revive */
        PostableApiAlertingConfig: {
            global: components['schemas']['GlobalConfig']
            inhibit_rules: components['schemas']['InhibitRule'][]
            /** @description MuteTimeIntervals is deprecated and will be removed before Alertmanager 1.0. */
            mute_time_intervals: components['schemas']['MuteTimeInterval'][]
            /** @description Override with our superset receiver type */
            receivers: components['schemas']['PostableApiReceiver'][]
            route: components['schemas']['Route']
            templates: string[]
            time_intervals: components['schemas']['TimeInterval'][]
        }
        /** @description nolint:revive */
        PostableApiReceiver: {
            discord_configs: components['schemas']['DiscordConfig'][]
            email_configs: components['schemas']['EmailConfig'][]
            grafana_managed_receiver_configs: components['schemas']['PostableGrafanaReceiver'][]
            jira_configs: components['schemas']['JiraConfig'][]
            msteams_configs: components['schemas']['MSTeamsConfig'][]
            /** @description A unique identifier for this receiver. */
            name: string
            opsgenie_configs: components['schemas']['OpsGenieConfig'][]
            pagerduty_configs: components['schemas']['PagerdutyConfig'][]
            pushover_configs: components['schemas']['PushoverConfig'][]
            slack_configs: components['schemas']['SlackConfig'][]
            sns_configs: components['schemas']['SNSConfig'][]
            telegram_configs: components['schemas']['TelegramConfig'][]
            victorops_configs: components['schemas']['VictorOpsConfig'][]
            webex_configs: components['schemas']['WebexConfig'][]
            webhook_configs: components['schemas']['WebhookConfig'][]
            wechat_configs: components['schemas']['WechatConfig'][]
        }
        PostableExtendedRuleNode: {
            alert: string
            annotations: {
                [key: string]: string
            }
            expr: string
            for: string
            grafana_alert: components['schemas']['PostableGrafanaRule']
            keep_firing_for: string
            labels: {
                [key: string]: string
            }
            record: string
        }
        PostableExtendedRuleNodeExtended: {
            /** @example project_x */
            folderTitle?: string
            /** @example okrd3I0Vz */
            folderUid?: string
            rule: components['schemas']['PostableExtendedRuleNode']
            /** @example eval_group_1 */
            ruleGroup?: string
        }
        PostableGrafanaReceiver: {
            disableResolveMessage: boolean
            name: string
            secureSettings: {
                [key: string]: string
            }
            settings: components['schemas']['RawMessage']
            type: string
            uid: string
        }
        PostableGrafanaReceivers: {
            grafana_managed_receiver_configs: components['schemas']['PostableGrafanaReceiver'][]
        }
        PostableGrafanaRule: {
            condition: string
            data: components['schemas']['AlertQuery'][]
            /** @enum {string} */
            exec_err_state: 'OK' | 'Alerting' | 'Error'
            is_paused: boolean
            metadata: components['schemas']['AlertRuleMetadata']
            /**
             * Format: int64
             * @description Number of consecutive evaluation intervals with no data for a dimension must pass
             *     before the alert state is considered stale and automatically resolved.
             *     If set to 0, the value is reset to the default.
             * @example 3
             */
            missing_series_evals_to_resolve: number
            /** @enum {string} */
            no_data_state: 'Alerting' | 'NoData' | 'OK'
            notification_settings: components['schemas']['AlertRuleNotificationSettings']
            record: components['schemas']['Record']
            title: string
            uid: string
        }
        PostableNGalertConfig: {
            /** @enum {string} */
            alertmanagersChoice: 'all' | 'internal' | 'external'
        }
        PostableRuleGroupConfig: {
            align_evaluation_time_on_interval: boolean
            evaluation_delay: string
            interval: components['schemas']['Duration']
            /** Format: int64 */
            limit: number
            name: string
            query_offset: string
            rules: components['schemas']['PostableExtendedRuleNode'][]
            source_tenants: string[]
        }
        PostableUserConfig: {
            alertmanager_config: components['schemas']['PostableApiAlertingConfig']
            template_files: {
                [key: string]: string
            }
        }
        /** @description Spec defines user, team or org Grafana preferences */
        Preferences: {
            cookiePreferences: components['schemas']['CookiePreferences']
            /** @description UID for the home dashboard */
            homeDashboardUID: string
            /** @description Selected language (beta) */
            language: string
            /** @description Selected locale (beta) */
            locale: string
            navbar: components['schemas']['NavbarPreference']
            queryHistory: components['schemas']['QueryHistoryPreference']
            /** @description light, dark, empty is default */
            theme: string
            /** @description The timezone selection
             *     TODO: this should use the timezone defined in common */
            timezone: string
            /** @description day of the week (sunday, monday, etc) */
            weekStart: string
        }
        PrometheusNamespace: {
            /** @description in: body */
            Body: {
                [key: string]: components['schemas']['PrometheusRuleGroup'][]
            }
        }
        PrometheusRemoteWriteTargetJSON: {
            data_source_uid: string
            id: string
            remote_write_path: string
        }
        PrometheusRule: {
            alert: string
            annotations: {
                [key: string]: string
            }
            expr: string
            for: string
            keep_firing_for: string
            labels: {
                [key: string]: string
            }
            record: string
        }
        PrometheusRuleGroup: {
            interval: components['schemas']['Duration']
            labels: {
                [key: string]: string
            }
            /** Format: int64 */
            limit: number
            name: string
            query_offset: string
            rules: components['schemas']['PrometheusRule'][]
        }
        Provenance: string
        ProvisionedAlertRule: {
            /** @example {
             *       "runbook_url": "https://supercoolrunbook.com/page/13"
             *     } */
            annotations?: {
                [key: string]: string
            }
            /** @example A */
            condition: string
            /** @example [
             *       {
             *         "datasourceUid": "__expr__",
             *         "model": {
             *           "conditions": [
             *             {
             *               "evaluator": {
             *                 "params": [
             *                   0,
             *                   0
             *                 ],
             *                 "type": "gt"
             *               },
             *               "operator": {
             *                 "type": "and"
             *               },
             *               "query": {
             *                 "params": []
             *               },
             *               "reducer": {
             *                 "params": [],
             *                 "type": "avg"
             *               },
             *               "type": "query"
             *             }
             *           ],
             *           "datasource": {
             *             "type": "__expr__",
             *             "uid": "__expr__"
             *           },
             *           "expression": "1 == 1",
             *           "hide": false,
             *           "intervalMs": 1000,
             *           "maxDataPoints": 43200,
             *           "refId": "A",
             *           "type": "math"
             *         },
             *         "queryType": "",
             *         "refId": "A",
             *         "relativeTimeRange": {
             *           "from": 0,
             *           "to": 0
             *         }
             *       }
             *     ] */
            data: components['schemas']['AlertQuery'][]
            /** @enum {string} */
            execErrState: 'OK' | 'Alerting' | 'Error'
            /** @example project_x */
            folderUID: string
            /** Format: duration */
            for: string
            /** Format: int64 */
            id?: number
            /** @example false */
            isPaused?: boolean
            /** Format: duration */
            keep_firing_for?: string
            /** @example {
             *       "team": "sre-team-1"
             *     } */
            labels?: {
                [key: string]: string
            }
            /**
             * Format: int64
             * @example 2
             */
            missingSeriesEvalsToResolve?: number
            /** @enum {string} */
            noDataState: 'Alerting' | 'NoData' | 'OK'
            notification_settings?: components['schemas']['AlertRuleNotificationSettings']
            /** Format: int64 */
            orgID: number
            provenance?: components['schemas']['Provenance']
            record?: components['schemas']['Record']
            /** @example eval_group_1 */
            ruleGroup: string
            /** @example Always firing */
            title: string
            uid?: string
            /** Format: date-time */
            readonly updated?: string
        }
        ProvisionedAlertRules: components['schemas']['ProvisionedAlertRule'][]
        ProxyConfig: {
            /** @description NoProxy contains addresses that should not use a proxy. */
            no_proxy: string
            proxy_connect_header: components['schemas']['ProxyHeader']
            /** @description ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function
             *     to determine proxies. */
            proxy_from_environment: boolean
            proxy_url: components['schemas']['URL']
        }
        ProxyHeader: {
            [key: string]: components['schemas']['Secret'][]
        }
        PublicDashboard: {
            accessToken: string
            annotationsEnabled: boolean
            /** Format: date-time */
            createdAt: string
            /** Format: int64 */
            createdBy: number
            dashboardUid: string
            isEnabled: boolean
            recipients: components['schemas']['EmailDTO'][]
            share: components['schemas']['ShareType']
            timeSelectionEnabled: boolean
            uid: string
            /** Format: date-time */
            updatedAt: string
            /** Format: int64 */
            updatedBy: number
        }
        PublicDashboardDTO: {
            accessToken: string
            annotationsEnabled: boolean
            isEnabled: boolean
            share: components['schemas']['ShareType']
            timeSelectionEnabled: boolean
            uid: string
        }
        PublicDashboardListResponse: {
            accessToken: string
            dashboardUid: string
            isEnabled: boolean
            slug: string
            title: string
            uid: string
        }
        PublicDashboardListResponseWithPagination: {
            /** Format: int64 */
            page: number
            /** Format: int64 */
            perPage: number
            publicDashboards: components['schemas']['PublicDashboardListResponse'][]
            /** Format: int64 */
            totalCount: number
        }
        /** @description PublicError is derived from Error and only contains information
         *     available to the end user. */
        PublicError: {
            extra: {
                [key: string]: unknown
            }
            message: string
            messageId: string
            /** Format: int64 */
            statusCode: number
        }
        /** Format: int64 */
        PublicKeyAlgorithm: number
        PushoverConfig: {
            device: string
            expire: string
            html: boolean
            http_config: components['schemas']['HTTPClientConfig']
            message: string
            priority: string
            retry: string
            send_resolved: boolean
            sound: string
            title: string
            token: components['schemas']['Secret']
            token_file: string
            ttl: string
            url: string
            url_title: string
            user_key: components['schemas']['Secret']
            user_key_file: string
        }
        /**
         * QueryDataResponse contains the results from a QueryDataRequest.
         * @description It is the return type of a QueryData call.
         */
        QueryDataResponse: {
            results: components['schemas']['Responses']
        }
        QueryHistoryDTO: {
            comment: string
            /** Format: int64 */
            createdAt: number
            /** Format: int64 */
            createdBy: number
            datasourceUid: string
            queries: components['schemas']['Json']
            starred: boolean
            uid: string
        }
        /** @description QueryHistoryDeleteQueryResponse is the response struct for deleting a query from query history */
        QueryHistoryDeleteQueryResponse: {
            /** Format: int64 */
            id: number
            message: string
        }
        QueryHistoryPreference: {
            /** @description one of: '' | 'query' | 'starred'; */
            homeTab: string
        }
        /** @description QueryHistoryResponse is a response struct for QueryHistoryDTO */
        QueryHistoryResponse: {
            result: components['schemas']['QueryHistoryDTO']
        }
        QueryHistorySearchResponse: {
            result: components['schemas']['QueryHistorySearchResult']
        }
        QueryHistorySearchResult: {
            /** Format: int64 */
            page: number
            /** Format: int64 */
            perPage: number
            queryHistory: components['schemas']['QueryHistoryDTO'][]
            /** Format: int64 */
            totalCount: number
        }
        /**
         * QueryStat is used for storing arbitrary statistics metadata related to a query and its result, e.g. total request time, data processing time.
         * @description The embedded FieldConfig's display name must be set.
         *     It corresponds to the QueryResultMetaStat on the frontend (https://github.com/grafana/grafana/blob/master/packages/grafana-data/src/types/data.ts#L53).
         */
        QueryStat: {
            /** @description Map values to a display color
             *     NOTE: this interface is under development in the frontend... so simple map for now */
            color: {
                [key: string]: unknown
            }
            /** @description Panel Specific Values */
            custom: {
                [key: string]: unknown
            }
            /** Format: uint16 */
            decimals: number
            /** @description Description is human readable field metadata */
            description: string
            /** @description DisplayName overrides Grafana default naming, should not be used from a data source */
            displayName: string
            /** @description DisplayNameFromDS overrides Grafana default naming strategy. */
            displayNameFromDS: string
            /** @description Filterable indicates if the Field's data can be filtered by additional calls. */
            filterable: boolean
            /**
             * Format: double
             * @description Interval indicates the expected regular step between values in the series.
             *     When an interval exists, consumers can identify "missing" values when the expected value is not present.
             *     The grafana timeseries visualization will render disconnected values when missing values are found it the time field.
             *     The interval uses the same units as the values.  For time.Time, this is defined in milliseconds.
             */
            interval: number
            /** @description The behavior when clicking on a result */
            links: components['schemas']['DataLink'][]
            mappings: components['schemas']['ValueMappings']
            max: components['schemas']['ConfFloat64']
            min: components['schemas']['ConfFloat64']
            /** @description Alternative to empty string */
            noValue: string
            /** @description Path is an explicit path to the field in the datasource. When the frame meta includes a path,
             *     this will default to `${frame.meta.path}/${field.name}
             *
             *     When defined, this value can be used as an identifier within the datasource scope, and
             *     may be used as an identifier to update values in a subsequent request */
            path: string
            thresholds: components['schemas']['ThresholdsConfig']
            type: components['schemas']['FieldTypeConfig']
            /** @description Numeric Options */
            unit: string
            /** Format: double */
            value: number
            /** @description Writeable indicates that the datasource knows how to update this value */
            writeable: boolean
        }
        QuotaDTO: {
            /** Format: int64 */
            limit: number
            /** Format: int64 */
            org_id: number
            target: string
            /** Format: int64 */
            used: number
            /** Format: int64 */
            user_id: number
        }
        RawMessage: Record<string, never>
        /** Receiver configuration provides configuration on how to contact a receiver. */
        Receiver: {
            discord_configs: components['schemas']['DiscordConfig'][]
            email_configs: components['schemas']['EmailConfig'][]
            jira_configs: components['schemas']['JiraConfig'][]
            msteams_configs: components['schemas']['MSTeamsConfig'][]
            /** @description A unique identifier for this receiver. */
            name: string
            opsgenie_configs: components['schemas']['OpsGenieConfig'][]
            pagerduty_configs: components['schemas']['PagerdutyConfig'][]
            pushover_configs: components['schemas']['PushoverConfig'][]
            slack_configs: components['schemas']['SlackConfig'][]
            sns_configs: components['schemas']['SNSConfig'][]
            telegram_configs: components['schemas']['TelegramConfig'][]
            victorops_configs: components['schemas']['VictorOpsConfig'][]
            webex_configs: components['schemas']['WebexConfig'][]
            webhook_configs: components['schemas']['WebhookConfig'][]
            wechat_configs: components['schemas']['WechatConfig'][]
        }
        /** ReceiverExport is the provisioned file export of alerting.ReceiverV1. */
        ReceiverExport: {
            disableResolveMessage: boolean
            settings: components['schemas']['RawMessage']
            type: string
            uid: string
        }
        Record: {
            /**
             * @description Which expression node should be used as the input for the recorded metric.
             * @example A
             */
            from: string
            /**
             * @description Name of the recorded metric.
             * @example grafana_alerts_ratio
             */
            metric: string
            /**
             * @description Which data source should be used to write the output of the recording rule, specified by UID.
             * @example my-prom
             */
            target_datasource_uid?: string
        }
        /** @description RecordingRuleJSON is the external representation of a recording rule */
        RecordingRuleJSON: {
            active: boolean
            count: boolean
            description: string
            dest_data_source_uid: string
            id: string
            /** Format: int64 */
            interval: number
            name: string
            prom_name: string
            queries: {
                [key: string]: unknown
            }[]
            /** Format: int64 */
            range: number
            target_ref_id: string
        }
        /** @description RelativeTimeRange is the per query start and end time
         *     for requests. */
        RelativeTimeRange: {
            from: components['schemas']['Duration']
            to: components['schemas']['Duration']
        }
        RelativeTimeRangeExport: {
            /** Format: int64 */
            from: number
            /** Format: int64 */
            to: number
        }
        Report: {
            /** Format: date-time */
            created: string
            dashboards: components['schemas']['ReportDashboard'][]
            enableCsv: boolean
            enableDashboardUrl: boolean
            formats: components['schemas']['Type'][]
            /** Format: int64 */
            id: number
            message: string
            name: string
            options: components['schemas']['ReportOptions']
            /** Format: int64 */
            orgId: number
            recipients: string
            replyTo: string
            /** Format: int64 */
            scaleFactor: number
            schedule: components['schemas']['ReportSchedule']
            state: components['schemas']['State']
            subject: string
            uid: string
            /** Format: date-time */
            updated: string
            /** Format: int64 */
            userId: number
        }
        ReportBrandingOptions: {
            emailFooterLink: string
            emailFooterMode: string
            emailFooterText: string
            emailLogoUrl: string
            reportLogoUrl: string
        }
        ReportDashboard: {
            dashboard: components['schemas']['ReportDashboardID']
            reportVariables: Record<string, never>
            timeRange: components['schemas']['ReportTimeRange']
        }
        ReportDashboardID: {
            /** Format: int64 */
            id: number
            name: string
            uid: string
        }
        ReportEmail: {
            /** @description Comma-separated list of emails to which to send the report to. */
            emails: string
            /**
             * Format: int64
             * @description Send the report to the emails specified in the report. Required if emails is not present.
             */
            id: string
            /** @description Send the report to the emails specified in the report. Required if emails is not present. */
            useEmailsFromReport: boolean
        }
        ReportOptions: {
            layout: string
            orientation: string
            pdfCombineOneFile: boolean
            pdfShowTemplateVariables: boolean
            timeRange: components['schemas']['ReportTimeRange']
        }
        ReportSchedule: {
            dayOfMonth: string
            /** Format: date-time */
            endDate: string
            frequency: string
            /** Format: int64 */
            intervalAmount: number
            intervalFrequency: string
            /** Format: date-time */
            startDate: string
            timeZone: string
            workdaysOnly: boolean
        }
        ReportSettings: {
            branding: components['schemas']['ReportBrandingOptions']
            embeddedImageTheme: string
            /** Format: int64 */
            id: number
            /** Format: int64 */
            orgId: number
            pdfTheme: string
            /** Format: int64 */
            userId: number
        }
        ReportTimeRange: {
            from: string
            to: string
        }
        ResourceDependenciesResponseDTO: {
            resourceDependencies: components['schemas']['ResourceDependencyDTO'][]
        }
        ResourceDependencyDTO: {
            dependencies: (
                | 'DASHBOARD'
                | 'DATASOURCE'
                | 'FOLDER'
                | 'LIBRARY_ELEMENT'
                | 'ALERT_RULE'
                | 'ALERT_RULE_GROUP'
                | 'CONTACT_POINT'
                | 'NOTIFICATION_POLICY'
                | 'NOTIFICATION_TEMPLATE'
                | 'MUTE_TIMING'
                | 'PLUGIN'
            )[]
            /** @enum {string} */
            resourceType:
                | 'DASHBOARD'
                | 'DATASOURCE'
                | 'FOLDER'
                | 'LIBRARY_ELEMENT'
                | 'ALERT_RULE'
                | 'ALERT_RULE_GROUP'
                | 'CONTACT_POINT'
                | 'NOTIFICATION_POLICY'
                | 'NOTIFICATION_TEMPLATE'
                | 'MUTE_TIMING'
                | 'PLUGIN'
        }
        ResponseDetails: {
            msg: string
        }
        /**
         * Responses is a map of RefIDs (Unique Query ID) to DataResponses.
         * @description The QueryData method the QueryDataHandler method will set the RefId
         *     property on the DataResponses' frames based on these RefIDs.
         */
        Responses: {
            [key: string]: components['schemas']['DataResponse']
        }
        RestoreDashboardVersionCommand: {
            /** Format: int64 */
            version: number
        }
        RestoreDeletedDashboardCommand: {
            folderUid: string
        }
        RevokeAuthTokenCmd: {
            /** Format: int64 */
            authTokenId: number
        }
        RoleAssignmentsDTO: {
            role_uid: string
            service_accounts: number[]
            teams: number[]
            users: number[]
        }
        RoleDTO: {
            /** Format: date-time */
            created: string
            delegatable: boolean
            description: string
            displayName: string
            global: boolean
            group: string
            hidden: boolean
            mapped: boolean
            name: string
            permissions: components['schemas']['Permission'][]
            uid: string
            /** Format: date-time */
            updated: string
            /** Format: int64 */
            version: number
        }
        RolesSearchQuery: {
            includeHidden: boolean
            /** Format: int64 */
            orgId: number
            teamIds: number[]
            userIds: number[]
        }
        /** @description A Route is a node that contains definitions of how to handle alerts. This is modified
         *     from the upstream alertmanager in that it adds the ObjectMatchers property. */
        Route: {
            active_time_intervals: string[]
            continue: boolean
            group_by: string[]
            group_interval: string
            group_wait: string
            /** @description Deprecated. Remove before v1.0 release. */
            match: {
                [key: string]: string
            }
            match_re: components['schemas']['MatchRegexps']
            matchers: components['schemas']['Matchers']
            mute_time_intervals: string[]
            object_matchers: components['schemas']['ObjectMatchers']
            provenance: components['schemas']['Provenance']
            receiver: string
            repeat_interval: string
            routes: components['schemas']['Route'][]
        }
        /** @description RouteExport is the provisioned file export of definitions.Route. This is needed to hide fields that aren't useable in
         *     provisioning file format. An alternative would be to define a custom MarshalJSON and MarshalYAML that excludes them. */
        RouteExport: {
            continue: boolean
            group_by: string[]
            group_interval: string
            group_wait: string
            /** @description Deprecated. Remove before v1.0 release. */
            match: {
                [key: string]: string
            }
            match_re: components['schemas']['MatchRegexps']
            matchers: components['schemas']['Matchers']
            mute_time_intervals: string[]
            object_matchers: components['schemas']['ObjectMatchers']
            receiver: string
            repeat_interval: string
            routes: components['schemas']['RouteExport'][]
        }
        /** @description adapted from cortex */
        Rule: {
            /** Format: double */
            evaluationTime?: number
            folderUid: string
            health: string
            labels?: components['schemas']['Labels']
            lastError?: string
            /** Format: date-time */
            lastEvaluation?: string
            name: string
            query: string
            type: string
            uid: string
        }
        RuleDiscovery: {
            groupNextToken?: string
            groups: components['schemas']['RuleGroup'][]
            totals?: {
                [key: string]: number
            }
        }
        RuleGroup: {
            /** Format: double */
            evaluationTime?: number
            file: string
            folderUid: string
            /** Format: double */
            interval: number
            /** Format: date-time */
            lastEvaluation?: string
            name: string
            /** @description In order to preserve rule ordering, while exposing type (alerting or recording)
             *     specific properties, both alerting and recording rules are exposed in the
             *     same array. */
            rules: components['schemas']['AlertingRule'][]
            totals?: {
                [key: string]: number
            }
        }
        RuleGroupConfigResponse: {
            align_evaluation_time_on_interval: boolean
            evaluation_delay: string
            interval: components['schemas']['Duration']
            /** Format: int64 */
            limit: number
            name: string
            query_offset: string
            rules: components['schemas']['GettableExtendedRuleNode'][]
            source_tenants: string[]
        }
        RuleResponse: {
            data?: components['schemas']['RuleDiscovery']
            error?: string
            errorType?: components['schemas']['ErrorType']
            status: string
        }
        SNSConfig: {
            api_url: string
            attributes: {
                [key: string]: string
            }
            http_config: components['schemas']['HTTPClientConfig']
            message: string
            phone_number: string
            send_resolved: boolean
            sigv4: components['schemas']['SigV4Config']
            subject: string
            target_arn: string
            topic_arn: string
        }
        /** @description Sample is a single sample belonging to a metric. It represents either a float
         *     sample or a histogram sample. If H is nil, it is a float sample. Otherwise,
         *     it is a histogram sample. */
        Sample: {
            /** @description DropName is used to indicate whether the __name__ label should be dropped
             *     as part of the query evaluation. */
            DropName: boolean
            /** Format: double */
            F: number
            H: components['schemas']['FloatHistogram']
            Metric: components['schemas']['Labels']
            /** Format: int64 */
            T: number
        }
        SaveDashboardCommand: {
            /** Format: date-time */
            UpdatedAt: string
            dashboard: components['schemas']['Json']
            /**
             * Format: int64
             * @description Deprecated: use FolderUID instead
             */
            folderId: number
            folderUid: string
            isFolder: boolean
            message: string
            overwrite: boolean
            /** Format: int64 */
            userId: number
        }
        SearchDTO: {
            action: string
            basicRole: string
            onlyRoles: boolean
            roleName: string
            scope: string
            teamId: string
            userId: string
        }
        SearchDeviceQueryResult: {
            devices: components['schemas']['DeviceSearchHitDTO'][]
            /** Format: int64 */
            page: number
            /** Format: int64 */
            perPage: number
            /** Format: int64 */
            totalCount: number
        }
        /** @description swagger: model */
        SearchOrgServiceAccountsResult: {
            /** Format: int64 */
            page: number
            /** Format: int64 */
            perPage: number
            serviceAccounts: components['schemas']['ServiceAccountDTO'][]
            /**
             * Format: int64
             * @description It can be used for pagination of the user list
             *     E.g. if totalCount is equal to 100 users and
             *     the perpage parameter is set to 10 then there are 10 pages of users.
             */
            totalCount: number
        }
        SearchOrgUsersQueryResult: {
            orgUsers: components['schemas']['OrgUserDTO'][]
            /** Format: int64 */
            page: number
            /** Format: int64 */
            perPage: number
            /** Format: int64 */
            totalCount: number
        }
        SearchResult: {
            result: components['schemas']['SearchResultItem'][]
        }
        SearchResultItem: {
            action: string
            basicRole: string
            /** Format: int64 */
            orgId: number
            roleName: string
            scope: string
            /** Format: int64 */
            teamId: number
            /** Format: int64 */
            userId: number
            /** Format: int64 */
            version: number
        }
        SearchTeamQueryResult: {
            /** Format: int64 */
            page: number
            /** Format: int64 */
            perPage: number
            teams: components['schemas']['TeamDTO'][]
            /** Format: int64 */
            totalCount: number
        }
        SearchUserQueryResult: {
            /** Format: int64 */
            page: number
            /** Format: int64 */
            perPage: number
            /** Format: int64 */
            totalCount: number
            users: components['schemas']['UserSearchHitDTO'][]
        }
        /** Secret special type for storing secrets. */
        Secret: string
        SecretURL: components['schemas']['URL']
        /** @description swagger: model */
        ServiceAccountDTO: {
            /** @example {
             *       "serviceaccounts:delete": true,
             *       "serviceaccounts:read": true,
             *       "serviceaccounts:write": true
             *     } */
            accessControl: {
                [key: string]: boolean
            }
            /** @example /avatar/85ec38023d90823d3e5b43ef35646af9 */
            avatarUrl: string
            /** Format: int64 */
            id: number
            /** @example false */
            isDisabled: boolean
            /** @example false */
            isExternal: boolean
            /** @example sa-grafana */
            login: string
            /** @example grafana */
            name: string
            /**
             * Format: int64
             * @example 1
             */
            orgId: number
            /** @example Viewer */
            role: string
            /**
             * Format: int64
             * @example 0
             */
            tokens: number
            /** @example fe1xejlha91xce */
            uid: string
        }
        ServiceAccountProfileDTO: {
            accessControl: {
                [key: string]: boolean
            }
            /** @example /avatar/8ea890a677d6a223c591a1beea6ea9d2 */
            avatarUrl: string
            /**
             * Format: date-time
             * @example 2022-03-21T14:35:33Z
             */
            createdAt: string
            /**
             * Format: int64
             * @example 2
             */
            id: number
            /** @example false */
            isDisabled: boolean
            /** @example false */
            isExternal: boolean
            /** @example sa-grafana */
            login: string
            /** @example test */
            name: string
            /**
             * Format: int64
             * @example 1
             */
            orgId: number
            /** @example grafana-app */
            requiredBy: string
            /** @example Editor */
            role: string
            /** @example [] */
            teams: string[]
            /** Format: int64 */
            tokens: number
            /** @example fe1xejlha91xce */
            uid: string
            /**
             * Format: date-time
             * @example 2022-03-21T14:35:33Z
             */
            updatedAt: string
        }
        SetResourcePermissionCommand: {
            builtInRole: string
            permission: string
            /** Format: int64 */
            teamId: number
            /** Format: int64 */
            userId: number
        }
        SetRoleAssignmentsCommand: {
            service_accounts: number[]
            teams: number[]
            users: number[]
        }
        SetTeamMembershipsCommand: {
            admins: string[]
            members: string[]
        }
        SetUserRolesCommand: {
            global: boolean
            includeHidden: boolean
            roleUids: string[]
        }
        SettingsBag: {
            [key: string]: {
                [key: string]: string
            }
        }
        ShareType: string
        /** @description SigV4Config is the configuration for signing remote write requests with
         *     AWS's SigV4 verification process. Empty values will be retrieved using the
         *     AWS default credentials chain. */
        SigV4Config: {
            AccessKey: string
            Profile: string
            Region: string
            RoleARN: string
            SecretKey: components['schemas']['Secret']
        }
        /** Format: int64 */
        SignatureAlgorithm: number
        SilenceMetadata: {
            folder_uid: string
            rule_title: string
            rule_uid: string
        }
        /**
         * SlackAction configures a single Slack action that is sent with each notification.
         * @description See https://api.slack.com/docs/message-attachments#action_fields and https://api.slack.com/docs/message-buttons
         *     for more information.
         */
        SlackAction: {
            confirm: components['schemas']['SlackConfirmationField']
            name: string
            style: string
            text: string
            type: string
            url: string
            value: string
        }
        /** SlackConfig configures notifications via Slack. */
        SlackConfig: {
            actions: components['schemas']['SlackAction'][]
            api_url: components['schemas']['SecretURL']
            api_url_file: string
            callback_id: string
            /** @description Slack channel override, (like #other-channel or @username). */
            channel: string
            color: string
            fallback: string
            fields: components['schemas']['SlackField'][]
            footer: string
            http_config: components['schemas']['HTTPClientConfig']
            icon_emoji: string
            icon_url: string
            image_url: string
            link_names: boolean
            mrkdwn_in: string[]
            pretext: string
            send_resolved: boolean
            short_fields: boolean
            text: string
            thumb_url: string
            title: string
            title_link: string
            username: string
        }
        /** @description SlackConfirmationField protect users from destructive actions or particularly distinguished decisions
         *     by asking them to confirm their button click one more time.
         *     See https://api.slack.com/docs/interactive-message-field-guide#confirmation_fields for more information. */
        SlackConfirmationField: {
            dismiss_text: string
            ok_text: string
            text: string
            title: string
        }
        /**
         * SlackField configures a single Slack field that is sent with each notification.
         * @description Each field must contain a title, value, and optionally, a boolean value to indicate if the field
         *     is short enough to be displayed next to other fields designated as short.
         *     See https://api.slack.com/docs/message-attachments#fields for more information.
         */
        SlackField: {
            short: boolean
            title: string
            value: string
        }
        SmtpNotEnabled: components['schemas']['ResponseDetails']
        /** @description Base snapshot without results */
        SnapshotDTO: {
            /** Format: date-time */
            created: string
            /** Format: date-time */
            finished: string
            sessionUid: string
            /** @enum {string} */
            status:
                | 'INITIALIZING'
                | 'CREATING'
                | 'PENDING_UPLOAD'
                | 'UPLOADING'
                | 'PENDING_PROCESSING'
                | 'PROCESSING'
                | 'FINISHED'
                | 'CANCELED'
                | 'ERROR'
                | 'UNKNOWN'
            uid: string
        }
        SnapshotListResponseDTO: {
            snapshots: components['schemas']['SnapshotDTO'][]
        }
        SnapshotResourceStats: {
            statuses: {
                [key: string]: number
            }
            /** Format: int64 */
            total: number
            types: {
                [key: string]: number
            }
        }
        /** Source type defines the status source. */
        Source: string
        /** A Span defines a continuous sequence of buckets. */
        Span: {
            /**
             * Format: uint32
             * @description Length of the span.
             */
            Length: number
            /**
             * Format: int32
             * @description Gap to previous span (always positive), or starting index for the 1st
             *     span (which can be negative).
             */
            Offset: number
        }
        /** @description +enum */
        State: string
        /** Format: int64 */
        Status: number
        Success: components['schemas']['ResponseDetails']
        SuccessResponseBody: {
            message: string
        }
        SupportedTransformationTypes: string
        /** SyncResult holds the result of a sync with LDAP. This gives us information on which users were updated and how. */
        SyncResult: {
            Elapsed: components['schemas']['Duration']
            FailedUsers: components['schemas']['FailedUser'][]
            MissingUserIds: number[]
            /** Format: date-time */
            Started: string
            UpdatedUserIds: number[]
        }
        /** TLSConfig configures the options for TLS connections. */
        TLSConfig: {
            /** @description Text of the CA cert to use for the targets. */
            ca: string
            /** @description The CA cert to use for the targets. */
            ca_file: string
            /** @description CARef is the name of the secret within the secret manager to use as the CA cert for the
             *     targets. */
            ca_ref: string
            /** @description Text of the client cert file for the targets. */
            cert: string
            /** @description The client cert file for the targets. */
            cert_file: string
            /** @description CertRef is the name of the secret within the secret manager to use as the client cert for
             *     the targets. */
            cert_ref: string
            /** @description Disable target certificate validation. */
            insecure_skip_verify: boolean
            key: components['schemas']['Secret']
            /** @description The client key file for the targets. */
            key_file: string
            /** @description KeyRef is the name of the secret within the secret manager to use as the client key for
             *     the targets. */
            key_ref: string
            max_version: components['schemas']['TLSVersion']
            min_version: components['schemas']['TLSVersion']
            /** @description Used to verify the hostname for the targets. */
            server_name: string
        }
        /** Format: uint16 */
        TLSVersion: number
        /** TagsDTO is the frontend DTO for Tag. */
        TagsDTO: {
            /** Format: int64 */
            count: number
            tag: string
        }
        TeamDTO: {
            accessControl: {
                [key: string]: boolean
            }
            avatarUrl: string
            email: string
            externalUID: string
            /** Format: int64 */
            id: number
            isProvisioned: boolean
            /** Format: int64 */
            memberCount: number
            name: string
            /** Format: int64 */
            orgId: number
            permission: components['schemas']['PermissionType']
            uid: string
        }
        TeamGroupDTO: {
            groupId: string
            /** Format: int64 */
            orgId: number
            /** Format: int64 */
            teamId: number
        }
        TeamGroupMapping: {
            groupId: string
        }
        TeamLBACRule: {
            rules: string[]
            teamId: string
            teamUid: string
        }
        TeamLBACRules: {
            rules: components['schemas']['TeamLBACRule'][]
        }
        TeamMemberDTO: {
            auth_module: string
            avatarUrl: string
            email: string
            labels: string[]
            login: string
            name: string
            /** Format: int64 */
            orgId: number
            permission: components['schemas']['PermissionType']
            /** Format: int64 */
            teamId: number
            teamUID: string
            /** Format: int64 */
            userId: number
            userUID: string
        }
        /** TelegramConfig configures notifications via Telegram. */
        TelegramConfig: {
            api_url: components['schemas']['URL']
            /** Format: int64 */
            chat: number
            disable_notifications: boolean
            http_config: components['schemas']['HTTPClientConfig']
            message: string
            parse_mode: string
            send_resolved: boolean
            token: components['schemas']['Secret']
            token_file: string
        }
        TempUserDTO: {
            code: string
            /** Format: date-time */
            createdOn: string
            email: string
            emailSent: boolean
            /** Format: date-time */
            emailSentOn: string
            /** Format: int64 */
            id: number
            invitedByEmail: string
            invitedByLogin: string
            invitedByName: string
            name: string
            /** Format: int64 */
            orgId: number
            /** @enum {string} */
            role: 'None' | 'Viewer' | 'Editor' | 'Admin'
            status: components['schemas']['TempUserStatus']
            url: string
        }
        TempUserStatus: string
        TestReceiverConfigResult: {
            error: string
            name: string
            status: string
            uid: string
        }
        TestReceiverResult: {
            grafana_managed_receiver_configs: components['schemas']['TestReceiverConfigResult'][]
            name: string
        }
        TestReceiversConfigAlertParams: {
            annotations: components['schemas']['LabelSet']
            labels: components['schemas']['LabelSet']
        }
        TestReceiversConfigBodyParams: {
            alert: components['schemas']['TestReceiversConfigAlertParams']
            receivers: components['schemas']['PostableApiReceiver'][]
        }
        TestReceiversResult: {
            alert: components['schemas']['TestReceiversConfigAlertParams']
            /** Format: date-time */
            notified_at: string
            receivers: components['schemas']['TestReceiverResult'][]
        }
        TestRulePayload: {
            /** @example (node_filesystem_avail_bytes{fstype!="",job="integrations/node_exporter"} node_filesystem_size_bytes{fstype!="",job="integrations/node_exporter"} * 100 < 5 and node_filesystem_readonly{fstype!="",job="integrations/node_exporter"} == 0) */
            expr: string
            grafana_condition: components['schemas']['EvalAlertConditionCommand']
        }
        TestRuleResponse: {
            alerts: components['schemas']['Vector']
            grafana_alert_instances: components['schemas']['AlertInstancesResponse']
        }
        TestTemplatesConfigBodyParams: {
            /** @description Alerts to use as data when testing the template. */
            alerts: components['schemas']['postableAlert'][]
            /** @description Name of the template file. */
            name: string
            /** @description Template string to test. */
            template: string
        }
        TestTemplatesErrorResult: {
            /**
             * @description Kind of template error that occurred.
             * @enum {string}
             */
            kind: 'invalid_template' | 'execution_error'
            /** @description Error message. */
            message: string
            /** @description Name of the associated template for this error. Will be empty if the Kind is "invalid_template". */
            name: string
        }
        TestTemplatesResult: {
            /** @description Name of the associated template definition for this result. */
            name: string
            /**
             * @description Scope that was successfully used to interpolate the template. If the root scope "." fails, more specific
             *     scopes will be tried, such as ".Alerts', or ".Alert".
             * @enum {string}
             */
            scope: '.' | '.Alerts' | '.Alert'
            /** @description Interpolated value of the template. */
            text: string
        }
        TestTemplatesResults: {
            errors: components['schemas']['TestTemplatesErrorResult'][]
            results: components['schemas']['TestTemplatesResult'][]
        }
        /** @description Threshold a single step on the threshold list */
        Threshold: {
            color: string
            state: string
            value: components['schemas']['ConfFloat64']
        }
        /** @description ThresholdsConfig setup thresholds */
        ThresholdsConfig: {
            mode: components['schemas']['ThresholdsMode']
            /** @description Must be sorted by 'value', first value is always -Infinity */
            steps: components['schemas']['Threshold'][]
        }
        /** @description ThresholdsMode absolute or percentage */
        ThresholdsMode: string
        /** TimeInterval represents a named set of time intervals for which a route should be muted. */
        TimeInterval: {
            name: string
            time_intervals: components['schemas']['TimeInterval'][]
        }
        /** @description Redefining this to avoid an import cycle */
        TimeRange: {
            /** Format: date-time */
            from: string
            /** Format: date-time */
            to: string
        }
        Token: {
            account: string
            /** Format: int64 */
            anonymousRatio: number
            company: string
            details_url: string
            /** Format: int64 */
            exp: number
            /** Format: int64 */
            iat: number
            /** Format: int64 */
            included_users: number
            iss: string
            jti: string
            /** Format: int64 */
            lexp: number
            /** Format: int64 */
            lic_exp_warn_days: number
            lid: string
            limit_by: string
            /** Format: int64 */
            max_concurrent_user_sessions: number
            /** Format: int64 */
            nbf: number
            prod: string[]
            slug: string
            status: components['schemas']['TokenStatus']
            sub: string
            /** Format: int64 */
            tok_exp_warn_days: number
            trial: boolean
            /** Format: int64 */
            trial_exp: number
            /** Format: int64 */
            update_days: number
            usage_billing: boolean
        }
        TokenDTO: {
            /**
             * Format: date-time
             * @example 2022-03-23T10:31:02Z
             */
            created: string
            /**
             * Format: date-time
             * @example 2022-03-23T10:31:02Z
             */
            expiration: string
            /** @example false */
            hasExpired: boolean
            /**
             * Format: int64
             * @example 1
             */
            id: number
            /** @example false */
            isRevoked: boolean
            /**
             * Format: date-time
             * @example 2022-03-23T10:31:02Z
             */
            lastUsedAt: string
            /** @example grafana */
            name: string
            /**
             * Format: double
             * @example 0
             */
            secondsUntilExpiration: number
        }
        /** Format: int64 */
        TokenStatus: number
        Transformation: {
            expression: string
            field: string
            mapValue: string
            /** @enum {string} */
            type: 'regex' | 'logfmt'
        }
        Transformations: components['schemas']['Transformation'][]
        /** @description +enum */
        Type: string
        /**
         * TypeMeta describes an individual object in an API response or request
         *     with strings representing the type of the object and its API schema version.
         *     Structures that are versioned or persisted should inline TypeMeta.
         * @description +k8s:deepcopy-gen=false
         */
        TypeMeta: {
            /** @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             *     +optional */
            apiVersion: string
            /** @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             *     +optional */
            kind: string
        }
        /**
         * A URL represents a parsed URL (technically, a URI reference).
         * @description The general form represented is:
         *
         *     [scheme:][//[userinfo@]host][/]path[?query][#fragment]
         *
         *     URLs that do not start with a slash after the scheme are interpreted as:
         *
         *     scheme:opaque[?query][#fragment]
         *
         *     The Host field contains the host and port subcomponents of the URL.
         *     When the port is present, it is separated from the host with a colon.
         *     When the host is an IPv6 address, it must be enclosed in square brackets:
         *     "[fe80::1]:80". The [net.JoinHostPort] function combines a host and port
         *     into a string suitable for the Host field, adding square brackets to
         *     the host when necessary.
         *
         *     Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.
         *     A consequence is that it is impossible to tell which slashes in the Path were
         *     slashes in the raw URL and which were %2f. This distinction is rarely important,
         *     but when it is, the code should use the [URL.EscapedPath] method, which preserves
         *     the original encoding of Path.
         *
         *     The RawPath field is an optional field which is only set when the default
         *     encoding of Path is different from the escaped path. See the EscapedPath method
         *     for more details.
         *
         *     URL's String method uses the EscapedPath method to obtain the path.
         */
        URL: {
            ForceQuery: boolean
            Fragment: string
            Host: string
            OmitHost: boolean
            Opaque: string
            Path: string
            RawFragment: string
            RawPath: string
            RawQuery: string
            Scheme: string
            User: components['schemas']['Userinfo']
        }
        /** @description Unstructured allows objects that do not have Golang structs registered to be manipulated
         *     generically. */
        Unstructured: {
            /** @description Object is a JSON compatible map with string, float, int, bool, []interface{},
             *     or map[string]interface{} children. */
            Object: {
                [key: string]: unknown
            }
        }
        UpdateAnnotationsCmd: {
            data: components['schemas']['Json']
            /** Format: int64 */
            id: number
            tags: string[]
            text: string
            /** Format: int64 */
            time: number
            /** Format: int64 */
            timeEnd: number
        }
        /** @description UpdateCorrelationCommand is the command for updating a correlation */
        UpdateCorrelationCommand: {
            config: components['schemas']['CorrelationConfigUpdateDTO']
            /**
             * @description Optional description of the correlation
             * @example Logs to Traces
             */
            description: string
            /**
             * @description Optional label identifying the correlation
             * @example My label
             */
            label: string
            type: components['schemas']['CorrelationType']
        }
        UpdateCorrelationResponseBody: {
            /** @example Correlation updated */
            message: string
            result: components['schemas']['Correlation']
        }
        UpdateDashboardACLCommand: {
            items: components['schemas']['DashboardACLUpdateItem'][]
        }
        /** @description Also acts as api DTO */
        UpdateDataSourceCommand: {
            access: components['schemas']['DsAccess']
            basicAuth: boolean
            basicAuthUser: string
            database: string
            isDefault: boolean
            jsonData: components['schemas']['Json']
            name: string
            secureJsonData: {
                [key: string]: string
            }
            type: string
            uid: string
            url: string
            user: string
            /** Format: int64 */
            version: number
            withCredentials: boolean
        }
        /** @description UpdateFolderCommand captures the information required by the folder service
         *     to update a folder. Use Move to update a folder's parent folder. */
        UpdateFolderCommand: {
            /** @description NewDescription it's an optional parameter used for overriding the existing folder description */
            description: string
            /** @description Overwrite only used by the legacy folder implementation */
            overwrite: boolean
            /** @description NewTitle it's an optional parameter used for overriding the existing folder title */
            title: string
            /**
             * Format: int64
             * @description Version only used by the legacy folder implementation
             */
            version: number
        }
        UpdateOrgAddressForm: {
            address1: string
            address2: string
            city: string
            country: string
            state: string
            zipcode: string
        }
        UpdateOrgForm: {
            name: string
        }
        UpdateOrgUserCommand: {
            /** @enum {string} */
            role: 'None' | 'Viewer' | 'Editor' | 'Admin'
        }
        UpdatePlaylistCommand: {
            interval: string
            items: components['schemas']['PlaylistItem'][]
            name: string
            uid: string
        }
        UpdatePrefsCmd: {
            cookies: components['schemas']['CookieType'][]
            /**
             * Format: int64
             * @description The numerical :id of a favorited dashboard
             * @default 0
             */
            homeDashboardId: number
            homeDashboardUID: string
            language: string
            locale: string
            navbar: components['schemas']['NavbarPreference']
            queryHistory: components['schemas']['QueryHistoryPreference']
            /** @enum {string} */
            theme: 'light' | 'dark' | 'system'
            /** @enum {string} */
            timezone: 'utc' | 'browser'
            weekStart: string
        }
        UpdateQuotaCmd: {
            /** Format: int64 */
            limit: number
            target: string
        }
        UpdateRoleCommand: {
            description: string
            displayName: string
            global: boolean
            group: string
            hidden: boolean
            name: string
            permissions: components['schemas']['Permission'][]
            /** Format: int64 */
            version: number
        }
        UpdateRuleGroupResponse: {
            created: string[]
            deleted: string[]
            message: string
            updated: string[]
        }
        UpdateServiceAccountForm: {
            isDisabled: boolean
            name: string
            /** @enum {string} */
            role: 'None' | 'Viewer' | 'Editor' | 'Admin'
            /** Format: int64 */
            serviceAccountId: number
        }
        UpdateTeamCommand: {
            Email: string
            /** Format: int64 */
            ID: number
            Name: string
        }
        UpdateTeamLBACCommand: {
            rules: components['schemas']['TeamLBACRule'][]
        }
        UpdateTeamMemberCommand: {
            permission: components['schemas']['PermissionType']
        }
        UpdateUserCommand: {
            email: string
            login: string
            name: string
            theme: string
        }
        /** UserInfo represents user-related information, including a unique identifier and a name. */
        UserInfo: {
            name: string
            uid: string
        }
        UserLookupDTO: {
            avatarUrl: string
            login: string
            uid: string
            /** Format: int64 */
            userId: number
        }
        UserOrgDTO: {
            name: string
            /** Format: int64 */
            orgId: number
            /** @enum {string} */
            role: 'None' | 'Viewer' | 'Editor' | 'Admin'
        }
        UserProfileDTO: {
            accessControl: {
                [key: string]: boolean
            }
            authLabels: string[]
            avatarUrl: string
            /** Format: date-time */
            createdAt: string
            email: string
            /** Format: int64 */
            id: number
            isDisabled: boolean
            isExternal: boolean
            isExternallySynced: boolean
            isGrafanaAdmin: boolean
            isGrafanaAdminExternallySynced: boolean
            isProvisioned: boolean
            login: string
            name: string
            /** Format: int64 */
            orgId: number
            theme: string
            uid: string
            /** Format: date-time */
            updatedAt: string
        }
        UserSearchHitDTO: {
            authLabels: string[]
            avatarUrl: string
            email: string
            /** Format: int64 */
            id: number
            isAdmin: boolean
            isDisabled: boolean
            isProvisioned: boolean
            /** Format: date-time */
            lastSeenAt: string
            lastSeenAtAge: string
            login: string
            name: string
            uid: string
        }
        /** @description UserToken represents a user token */
        UserToken: {
            AuthToken: string
            AuthTokenSeen: boolean
            ClientIp: string
            /** Format: int64 */
            CreatedAt: number
            /** Format: int64 */
            ExternalSessionId: number
            /** Format: int64 */
            Id: number
            PrevAuthToken: string
            /** Format: int64 */
            RevokedAt: number
            /** Format: int64 */
            RotatedAt: number
            /** Format: int64 */
            SeenAt: number
            UnhashedToken: string
            /** Format: int64 */
            UpdatedAt: number
            UserAgent: string
            /** Format: int64 */
            UserId: number
        }
        /** @description The Userinfo type is an immutable encapsulation of username and
         *     password details for a [URL]. An existing Userinfo value is guaranteed
         *     to have a username set (potentially empty, as allowed by RFC 2396),
         *     and optionally a password. */
        Userinfo: Record<string, never>
        ValidationError: {
            /** @example error message */
            message: string
        }
        /** @description ValueMapping allows mapping input values to text and color */
        ValueMapping: Record<string, never>
        ValueMappings: components['schemas']['ValueMapping'][]
        /** @description Vector is basically only an alias for []Sample, but the contract is that
         *     in a Vector, all Samples have the same timestamp. */
        Vector: components['schemas']['Sample'][]
        /** VictorOpsConfig configures notifications via VictorOps. */
        VictorOpsConfig: {
            api_key: components['schemas']['Secret']
            api_key_file: string
            api_url: components['schemas']['URL']
            custom_fields: {
                [key: string]: string
            }
            entity_display_name: string
            http_config: components['schemas']['HTTPClientConfig']
            message_type: string
            monitoring_tool: string
            routing_key: string
            send_resolved: boolean
            state_message: string
        }
        /** VisType is used to indicate how the data should be visualized in explore. */
        VisType: string
        /** WebexConfig configures notifications via Webex. */
        WebexConfig: {
            api_url: components['schemas']['URL']
            http_config: components['schemas']['HTTPClientConfig']
            message: string
            room_id: string
            send_resolved: boolean
        }
        /** WebhookConfig configures notifications via a generic webhook. */
        WebhookConfig: {
            http_config: components['schemas']['HTTPClientConfig']
            /**
             * Format: uint64
             * @description MaxAlerts is the maximum number of alerts to be sent per webhook message.
             *     Alerts exceeding this threshold will be truncated. Setting this to 0
             *     allows an unlimited number of alerts.
             */
            max_alerts: number
            send_resolved: boolean
            timeout: components['schemas']['Duration']
            url: components['schemas']['SecretURL']
            url_file: string
        }
        /** WechatConfig configures notifications via Wechat. */
        WechatConfig: {
            agent_id: string
            api_secret: components['schemas']['Secret']
            api_url: components['schemas']['URL']
            corp_id: string
            http_config: components['schemas']['HTTPClientConfig']
            message: string
            message_type: string
            send_resolved: boolean
            to_party: string
            to_tag: string
            to_user: string
        }
        /** @description Alert alert */
        alert: {
            /**
             * Format: uri
             * @description generator URL
             *     Format: uri
             */
            generatorURL?: string
            labels: components['schemas']['labelSet']
        }
        /** @description AlertGroup alert group */
        alertGroup: {
            /** @description alerts */
            alerts: components['schemas']['gettableAlert'][]
            labels: components['schemas']['labelSet']
            receiver: components['schemas']['receiver']
        }
        /** @description AlertGroups alert groups */
        alertGroups: components['schemas']['alertGroup'][]
        /** @description AlertStatus alert status */
        alertStatus: {
            /** @description inhibited by */
            inhibitedBy: string[]
            /** @description silenced by */
            silencedBy: string[]
            /**
             * @description state
             * @enum {string}
             */
            state: '[unprocessed active suppressed]'
        }
        /** @description AlertmanagerConfig alertmanager config */
        alertmanagerConfig: {
            /** @description original */
            original: string
        }
        /** @description AlertmanagerStatus alertmanager status */
        alertmanagerStatus: {
            cluster: components['schemas']['clusterStatus']
            config: components['schemas']['alertmanagerConfig']
            /**
             * Format: date-time
             * @description uptime
             */
            uptime: string
            versionInfo: components['schemas']['versionInfo']
        }
        /** @description ClusterStatus cluster status */
        clusterStatus: {
            /** @description name */
            name?: string
            /** @description peers */
            peers?: components['schemas']['peerStatus'][]
            /**
             * @description status
             * @enum {string}
             */
            status: '[ready settling disabled]'
        }
        deviceDTO: {
            avatarUrl: string
            clientIp: string
            /** Format: date-time */
            createdAt: string
            deviceId: string
            lastSeenAt: string
            /** Format: date-time */
            updatedAt: string
            userAgent: string
        }
        getGroupsResponse: {
            groups: components['schemas']['Group'][]
            /** Format: int64 */
            total: number
        }
        /** @description GettableAlert gettable alert */
        gettableAlert: {
            annotations: components['schemas']['labelSet']
            /**
             * Format: date-time
             * @description ends at
             */
            endsAt: string
            /** @description fingerprint */
            fingerprint: string
            /**
             * Format: uri
             * @description generator URL
             *     Format: uri
             */
            generatorURL?: string
            labels: components['schemas']['labelSet']
            /** @description receivers */
            receivers: components['schemas']['receiver'][]
            /**
             * Format: date-time
             * @description starts at
             */
            startsAt: string
            status: components['schemas']['alertStatus']
            /**
             * Format: date-time
             * @description updated at
             */
            updatedAt: string
        }
        gettableAlerts: components['schemas']['gettableAlert'][]
        gettableGrafanaSilence: {
            /** @example {
             *       "create": false,
             *       "read": true,
             *       "write": false
             *     } */
            accessControl?: {
                [key: string]: boolean
            }
            /** @description comment */
            comment: string
            /** @description created by */
            createdBy: string
            /**
             * Format: date-time
             * @description ends at
             */
            endsAt: string
            /** @description id */
            id: string
            matchers: components['schemas']['matchers']
            metadata?: components['schemas']['SilenceMetadata']
            /**
             * Format: date-time
             * @description starts at
             */
            startsAt: string
            status: components['schemas']['silenceStatus']
            /**
             * Format: date-time
             * @description updated at
             */
            updatedAt: string
        }
        gettableGrafanaSilences: components['schemas']['gettableGrafanaSilence'][]
        /** @description GettableSilence gettable silence */
        gettableSilence: {
            /** @description comment */
            comment: string
            /** @description created by */
            createdBy: string
            /**
             * Format: date-time
             * @description ends at
             */
            endsAt: string
            /** @description id */
            id: string
            matchers: components['schemas']['matchers']
            /**
             * Format: date-time
             * @description starts at
             */
            startsAt: string
            status: components['schemas']['silenceStatus']
            /**
             * Format: date-time
             * @description updated at
             */
            updatedAt: string
        }
        gettableSilences: components['schemas']['gettableSilence'][]
        healthResponse: {
            commit: string
            database: string
            enterpriseCommit: string
            version: string
        }
        /** @description LabelSet label set */
        labelSet: {
            [key: string]: string
        }
        /** @description Matcher matcher */
        matcher: {
            /** @description is equal */
            isEqual?: boolean
            /** @description is regex */
            isRegex: boolean
            /** @description name */
            name: string
            /** @description value */
            value: string
        }
        /** @description Matchers matchers */
        matchers: components['schemas']['matcher'][]
        messageResponse: {
            message: string
        }
        /** @description PeerStatus peer status */
        peerStatus: {
            /** @description address */
            address: string
            /** @description name */
            name: string
        }
        postSilencesOKBody: {
            /** @description silence ID */
            silenceID: string
        }
        /** @description PostableAlert postable alert */
        postableAlert: {
            annotations?: components['schemas']['labelSet']
            /**
             * Format: date-time
             * @description ends at
             *     Format: date-time
             */
            endsAt?: string
            /**
             * Format: uri
             * @description generator URL
             *     Format: uri
             */
            generatorURL?: string
            labels: components['schemas']['labelSet']
            /**
             * Format: date-time
             * @description starts at
             *     Format: date-time
             */
            startsAt?: string
        }
        /** @description PostableAlerts postable alerts */
        postableAlerts: components['schemas']['postableAlert'][]
        /** @description PostableSilence postable silence */
        postableSilence: {
            /** @description comment */
            comment: string
            /** @description created by */
            createdBy: string
            /**
             * Format: date-time
             * @description ends at
             */
            endsAt: string
            /** @description id */
            id?: string
            matchers: components['schemas']['matchers']
            /**
             * Format: date-time
             * @description starts at
             */
            startsAt: string
        }
        /** @description PublicError is derived from Error and only contains information
         *     available to the end user. */
        publicError: {
            /** @description Extra Additional information about the error */
            extra?: {
                [key: string]: unknown
            }
            /** @description Message A human readable message */
            message?: string
            /** @description MessageID A unique identifier for the error */
            messageId: string
            /**
             * Format: int64
             * @description StatusCode The HTTP status code returned
             */
            statusCode: number
        }
        /** @description Receiver receiver */
        receiver: {
            /** @description name */
            name: string
        }
        resourcePermissionDTO: {
            actions: string[]
            builtInRole: string
            /** Format: int64 */
            id: number
            isInherited: boolean
            isManaged: boolean
            isServiceAccount: boolean
            permission: string
            roleName: string
            team: string
            teamAvatarUrl: string
            /** Format: int64 */
            teamId: number
            teamUid: string
            userAvatarUrl: string
            /** Format: int64 */
            userId: number
            userLogin: string
            userUid: string
        }
        setPermissionCommand: {
            permission: string
        }
        setPermissionsCommand: {
            permissions: components['schemas']['SetResourcePermissionCommand'][]
        }
        /** @description Silence silence */
        silence: {
            /** @description comment */
            comment: string
            /** @description created by */
            createdBy: string
            /**
             * Format: date-time
             * @description ends at
             */
            endsAt: string
            matchers: components['schemas']['matchers']
            /**
             * Format: date-time
             * @description starts at
             */
            startsAt: string
        }
        /** @description SilenceStatus silence status */
        silenceStatus: {
            /**
             * @description state
             * @enum {string}
             */
            state: '[expired active pending]'
        }
        /** @description VersionInfo version info */
        versionInfo: {
            /** @description branch */
            branch: string
            /** @description build date */
            buildDate: string
            /** @description build user */
            buildUser: string
            /** @description go version */
            goVersion: string
            /** @description revision */
            revision: string
            /** @description version */
            version: string
        }
    }
    responses: {
        /** @description (empty) */
        GettableHistoricUserConfigs: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['GettableHistoricUserConfig'][]
            }
        }
        /** @description (empty) */
        SMTPNotEnabledError: {
            headers: {
                [name: string]: unknown
            }
            content?: never
        }
        /** @description (empty) */
        StateHistory: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Frame']
            }
        }
        /** @description (empty) */
        TestGrafanaRuleResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['postableAlert'][]
            }
        }
        /** @description AcceptedResponse */
        acceptedResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ErrorResponseBody']
            }
        }
        /** @description (empty) */
        adminCreateUserResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['AdminCreateUserResponse']
            }
        }
        /** @description (empty) */
        adminGetSettingsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['SettingsBag']
            }
        }
        /** @description (empty) */
        adminGetStatsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['AdminStats']
            }
        }
        /** @description (empty) */
        adminGetUserAuthTokensResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['UserToken'][]
            }
        }
        /** @description (empty) */
        apiResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['messageResponse']
            }
        }
        /** @description BadRequestError is returned when the request is invalid and it cannot be processed. */
        badRequestError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ErrorResponseBody']
            }
        }
        /** @description BadRequestPublicError is returned when the request is invalid and it cannot be processed. */
        badRequestPublicError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['publicError']
            }
        }
        /** @description (empty) */
        calculateDashboardDiffResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': number[]
            }
        }
        /** @description (empty) */
        cloudMigrationCreateTokenResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['CreateAccessTokenResponseDTO']
            }
        }
        /** @description (empty) */
        cloudMigrationDeleteTokenResponse: {
            headers: {
                [name: string]: unknown
            }
            content?: never
        }
        /** @description (empty) */
        cloudMigrationGetTokenResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['GetAccessTokenResponseDTO']
            }
        }
        /** @description (empty) */
        cloudMigrationRunListResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['CloudMigrationRunListDTO']
            }
        }
        /** @description (empty) */
        cloudMigrationRunResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['MigrateDataResponseDTO']
            }
        }
        /** @description (empty) */
        cloudMigrationSessionListResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['CloudMigrationSessionListResponseDTO']
            }
        }
        /** @description (empty) */
        cloudMigrationSessionResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['CloudMigrationSessionResponseDTO']
            }
        }
        /** @description ConflictError */
        conflictError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ErrorResponseBody']
            }
        }
        /** @description (empty) */
        contentResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': number[]
            }
        }
        /** @description (empty) */
        createCorrelationResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['CreateCorrelationResponseBody']
            }
        }
        /** @description (empty) */
        createDashboardSnapshotResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    /** @description Unique key used to delete the snapshot. It is different from the key so that only the creator can delete the snapshot. */
                    deleteKey: string
                    deleteUrl: string
                    /**
                     * Format: int64
                     * @description Snapshot id
                     */
                    id: number
                    /** @description Unique key */
                    key: string
                    url: string
                }
            }
        }
        /** @description (empty) */
        createOrUpdateDatasourceResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    datasource: components['schemas']['DataSource']
                    /**
                     * Format: int64
                     * @description ID Identifier of the new data source.
                     * @example 65
                     */
                    id: number
                    /**
                     * @description Message Message of the deleted dashboard.
                     * @example Data source added
                     */
                    message: string
                    /**
                     * @description Name of the new data source.
                     * @example My Data source
                     */
                    name: string
                }
            }
        }
        /** @description (empty) */
        createOrgResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    /**
                     * @description Message Message of the created org.
                     * @example Data source added
                     */
                    message: string
                    /**
                     * Format: int64
                     * @description ID Identifier of the created org.
                     * @example 65
                     */
                    orgId: number
                }
            }
        }
        /** @description (empty) */
        createPlaylistResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Playlist']
            }
        }
        /** @description (empty) */
        createPublicDashboardResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['PublicDashboard']
            }
        }
        /** @description (empty) */
        createReportResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    /** Format: int64 */
                    id: number
                    message: string
                }
            }
        }
        /** @description (empty) */
        createRoleResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['RoleDTO']
            }
        }
        /** @description (empty) */
        createServiceAccountResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ServiceAccountDTO']
            }
        }
        /** @description (empty) */
        createSnapshotResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['CreateSnapshotResponseDTO']
            }
        }
        /** @description (empty) */
        createTeamResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    message: string
                    /** Format: int64 */
                    teamId: number
                    uid: string
                }
            }
        }
        /** @description (empty) */
        createTokenResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['NewApiKeyResult']
            }
        }
        /** @description (empty) */
        dashboardResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['DashboardFullWithMeta']
            }
        }
        /** @description (empty) */
        dashboardVersionResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['DashboardVersionMeta']
            }
        }
        /** @description (empty) */
        dashboardVersionsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['DashboardVersionMeta'][]
            }
        }
        /** @description (empty) */
        deleteCorrelationResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['DeleteCorrelationResponseBody']
            }
        }
        /** @description (empty) */
        deleteDashboardResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    /**
                     * @description Message Message of the deleted dashboard.
                     * @example Dashboard My Dashboard deleted
                     */
                    message: string
                    /**
                     * @description Title Title of the deleted dashboard.
                     * @example My Dashboard
                     */
                    title: string
                    /**
                     * @description UID Identifier of the deleted dashboard.
                     * @example 65
                     */
                    uid: string
                }
            }
        }
        /** @description (empty) */
        deleteDataSourceByNameResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    /**
                     * Format: int64
                     * @description ID Identifier of the deleted data source.
                     * @example 65
                     */
                    id: number
                    /**
                     * @description Message Message of the deleted dashboard.
                     * @example Dashboard My Dashboard deleted
                     */
                    message: string
                }
            }
        }
        /** @description (empty) */
        deleteFolderResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    /**
                     * Format: int64
                     * @description ID Identifier of the deleted folder.
                     * @example 65
                     */
                    id: number
                    /**
                     * @description Message Message of the deleted folder.
                     * @example Folder My Folder deleted
                     */
                    message: string
                    /**
                     * @description Title of the deleted folder.
                     * @example My Folder
                     */
                    title: string
                }
            }
        }
        /** @description (empty) */
        devicesResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['deviceDTO'][]
            }
        }
        /** @description (empty) */
        devicesSearchResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['SearchDeviceQueryResult']
            }
        }
        /** @description (empty) */
        folderResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Folder']
            }
        }
        /** @description ForbiddenError is returned if the user/token has insufficient permissions to access the requested resource. */
        forbiddenError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ErrorResponseBody']
            }
        }
        /** @description ForbiddenPublicError is returned if the user/token has insufficient permissions to access the requested resource. */
        forbiddenPublicError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['publicError']
            }
        }
        /** @description A GenericError is the default error message that is generated.
         *     For certain status codes there are more appropriate error structures. */
        genericError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ErrorResponseBody']
            }
        }
        /** @description (empty) */
        getAPIkeyResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ApiKeyDTO'][]
            }
        }
        /** @description (empty) */
        getAccessControlStatusResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Status']
            }
        }
        /** @description (empty) */
        getAllRolesResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['RoleDTO'][]
            }
        }
        /** @description (empty) */
        getAnnotationByIDResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Annotation']
            }
        }
        /** @description (empty) */
        getAnnotationTagsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['GetAnnotationTagsResponse']
            }
        }
        /** @description (empty) */
        getAnnotationsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Annotation'][]
            }
        }
        /** @description (empty) */
        getCorrelationResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Correlation']
            }
        }
        /** @description (empty) */
        getCorrelationsBySourceUIDResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Correlation'][]
            }
        }
        /** @description (empty) */
        getCorrelationsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Correlation'][]
            }
        }
        /** @description (empty) */
        getCurrentOrgResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['OrgDetailsDTO']
            }
        }
        /** @description (empty) */
        getDashboardPermissionsListResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['DashboardACLInfoDTO'][]
            }
        }
        /** @description (empty) */
        getDashboardSnapshotResponse: {
            headers: {
                [name: string]: unknown
            }
            content?: never
        }
        /** @description (empty) */
        getDashboardsTagsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['DashboardTagCloudItem'][]
            }
        }
        /** @description (empty) */
        getDataSourceIDResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    /**
                     * Format: int64
                     * @description ID Identifier of the data source.
                     * @example 65
                     */
                    id: number
                }
            }
        }
        /** @description (empty) */
        getDataSourceResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['DataSource']
            }
        }
        /** @description (empty) */
        getDataSourcesResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['DataSourceList']
            }
        }
        /** @description (empty) */
        getFolderDescendantCountsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['DescendantCounts']
            }
        }
        /** @description (empty) */
        getFolderPermissionListResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['DashboardACLInfoDTO'][]
            }
        }
        /** @description (empty) */
        getFoldersResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['FolderSearchHit'][]
            }
        }
        /** @description (empty) */
        getGroupRolesResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['RoleDTO'][]
            }
        }
        /** @description (empty) */
        getGroupsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['getGroupsResponse']
            }
        }
        /** @description (empty) */
        getHomeDashboardResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['GetHomeDashboardResponse']
            }
        }
        /** @description (empty) */
        getLibraryElementArrayResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['LibraryElementArrayResponse']
            }
        }
        /** @description (empty) */
        getLibraryElementConnectionsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['LibraryElementConnectionsResponse']
            }
        }
        /** @description (empty) */
        getLibraryElementResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['LibraryElementResponse']
            }
        }
        /** @description (empty) */
        getLibraryElementsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['LibraryElementSearchResponse']
            }
        }
        /** @description (empty) */
        getLicenseTokenResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Token']
            }
        }
        /** @description (empty) */
        getOrgByIDResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['OrgDetailsDTO']
            }
        }
        /** @description (empty) */
        getOrgByNameResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['OrgDetailsDTO']
            }
        }
        /** @description (empty) */
        getOrgUsersForCurrentOrgLookupResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['UserLookupDTO'][]
            }
        }
        /** @description (empty) */
        getOrgUsersForCurrentOrgResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['OrgUserDTO'][]
            }
        }
        /** @description (empty) */
        getOrgUsersResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['OrgUserDTO'][]
            }
        }
        /** @description (empty) */
        getPendingOrgInvitesResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['TempUserDTO'][]
            }
        }
        /** @description (empty) */
        getPlaylistDashboardsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['PlaylistDashboardsSlice']
            }
        }
        /** @description (empty) */
        getPlaylistItemsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['PlaylistItemDTO'][]
            }
        }
        /** @description (empty) */
        getPlaylistResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['PlaylistDTO']
            }
        }
        /** @description (empty) */
        getPreferencesResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Preferences']
            }
        }
        /** @description (empty) */
        getPublicAnnotationsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['AnnotationEvent'][]
            }
        }
        /** @description (empty) */
        getPublicDashboardResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['PublicDashboard']
            }
        }
        /** @description (empty) */
        getQueryHistoryDeleteQueryResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['QueryHistoryDeleteQueryResponse']
            }
        }
        /** @description (empty) */
        getQueryHistoryResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['QueryHistoryResponse']
            }
        }
        /** @description (empty) */
        getQueryHistorySearchResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['QueryHistorySearchResponse']
            }
        }
        /** @description (empty) */
        getQuotaResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['QuotaDTO'][]
            }
        }
        /** @description (empty) */
        getReportResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Report']
            }
        }
        /** @description (empty) */
        getReportSettingsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ReportSettings']
            }
        }
        /** @description (empty) */
        getReportsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Report'][]
            }
        }
        /** @description (empty) */
        getResourcePermissionsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['resourcePermissionDTO'][]
            }
        }
        /** @description (empty) */
        getRoleAssignmentsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['RoleAssignmentsDTO']
            }
        }
        /** @description (empty) */
        getRoleResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['RoleDTO']
            }
        }
        /** @description (empty) */
        getSSOSettingsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    id: string
                    provider: string
                    settings: {
                        [key: string]: unknown
                    }
                    source: string
                }
            }
        }
        /** @description (empty) */
        getSharingOptionsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    externalEnabled: boolean
                    externalSnapshotName: string
                    externalSnapshotURL: string
                }
            }
        }
        /** @description (empty) */
        getSignedInUserOrgListResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['UserOrgDTO'][]
            }
        }
        /** @description (empty) */
        getSignedInUserTeamListResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['TeamDTO'][]
            }
        }
        /** @description (empty) */
        getSnapshotResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['GetSnapshotResponseDTO']
            }
        }
        /** @description (empty) */
        getStatusResponse: {
            headers: {
                [name: string]: unknown
            }
            content?: never
        }
        /** @description (empty) */
        getSyncStatusResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ActiveSyncStatusDTO']
            }
        }
        /** @description (empty) */
        getTeamByIDResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['TeamDTO']
            }
        }
        /** @description (empty) */
        getTeamGroupsApiResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['TeamGroupDTO'][]
            }
        }
        /** @description (empty) */
        getTeamLBACRulesResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['TeamLBACRules']
            }
        }
        /** @description (empty) */
        getTeamMembersResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['TeamMemberDTO'][]
            }
        }
        /** @description (empty) */
        getUserAuthTokensResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['UserToken'][]
            }
        }
        /** @description (empty) */
        getUserOrgListResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['UserOrgDTO'][]
            }
        }
        /** @description (empty) */
        getUserTeamsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['TeamDTO'][]
            }
        }
        /** @description GoneError is returned when the requested endpoint was removed. */
        goneError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ErrorResponseBody']
            }
        }
        /** @description (empty) */
        helpFlagResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    /** Format: int64 */
                    helpFlags1: number
                    message: string
                }
            }
        }
        /** @description (empty) */
        importDashboardResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ImportDashboardResponse']
            }
        }
        /** @description InternalServerError is a general error indicating something went wrong internally. */
        internalServerError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ErrorResponseBody']
            }
        }
        /** @description InternalServerPublicError is a general error indicating something went wrong internally. */
        internalServerPublicError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['publicError']
            }
        }
        /** @description (empty) */
        jwksResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    keys: components['schemas']['JSONWebKey'][]
                }
            }
        }
        /** @description (empty) */
        listBuiltinRolesResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    [key: string]: components['schemas']['RoleDTO'][]
                }
            }
        }
        /** @description (empty) */
        listPublicDashboardsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['PublicDashboardListResponseWithPagination']
            }
        }
        /** @description (empty) */
        listRecordingRulesResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['RecordingRuleJSON'][]
            }
        }
        /** @description (empty) */
        listRolesResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['RoleDTO'][]
            }
        }
        /** @description (empty) */
        listSSOSettingsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    id: string
                    provider: string
                    settings: {
                        [key: string]: unknown
                    }
                    source: string
                }[]
            }
        }
        /** @description (empty) */
        listSortOptionsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    description: string
                    displayName: string
                    meta: string
                    name: string
                }
            }
        }
        /** @description (empty) */
        listTeamsRolesResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    [key: string]: components['schemas']['RoleDTO'][]
                }
            }
        }
        /** @description (empty) */
        listTokensResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['TokenDTO'][]
            }
        }
        /** @description (empty) */
        listUsersRolesResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    [key: string]: components['schemas']['RoleDTO'][]
                }
            }
        }
        /** @description (empty) */
        noContentResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': Record<string, never>
            }
        }
        /** @description NotAcceptableError is returned when the server cannot produce a response matching the accepted formats. */
        notAcceptableError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ErrorResponseBody']
            }
        }
        /** @description NotFoundError is returned when the requested resource was not found. */
        notFoundError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ErrorResponseBody']
            }
        }
        /** @description NotFoundPublicError is returned when the requested resource was not found. */
        notFoundPublicError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['publicError']
            }
        }
        /** @description An OKResponse is returned if the request was successful. */
        okResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['SuccessResponseBody']
            }
        }
        /** @description (empty) */
        postAnnotationResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    /**
                     * Format: int64
                     * @description ID Identifier of the created annotation.
                     * @example 65
                     */
                    id: number
                    /** @description Message Message of the created annotation. */
                    message: string
                }
            }
        }
        /** @description (empty) */
        postDashboardResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    /** @description FolderUID The unique identifier (uid) of the folder the dashboard belongs to. */
                    folderUid?: string
                    /**
                     * Format: int64
                     * @description ID The unique identifier (id) of the created/updated dashboard.
                     * @example 1
                     */
                    id: number
                    /**
                     * @description Status status of the response.
                     * @example success
                     */
                    status: string
                    /**
                     * @description Slug The slug of the dashboard.
                     * @example my-dashboard
                     */
                    title: string
                    /**
                     * @description UID The unique identifier (uid) of the created/updated dashboard.
                     * @example nHz3SXiiz
                     */
                    uid: string
                    /**
                     * @description URL The relative URL for accessing the created/updated dashboard.
                     * @example /d/nHz3SXiiz/my-dashboard
                     */
                    url: string
                    /**
                     * Format: int64
                     * @description Version The version of the dashboard.
                     * @example 2
                     */
                    version: number
                }
            }
        }
        /** @description (empty) */
        postRenewLicenseTokenResponse: {
            headers: {
                [name: string]: unknown
            }
            content?: never
        }
        /** @description PreconditionFailedError */
        preconditionFailedError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ErrorResponseBody']
            }
        }
        /** @description (empty) */
        publicErrorResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['publicError']
            }
        }
        /** @description (empty) */
        queryMetricsWithExpressionsRespons: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['QueryDataResponse']
            }
        }
        /** @description (empty) */
        queryPublicDashboardResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['QueryDataResponse']
            }
        }
        /** @description (empty) */
        receiversResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Receiver'][]
            }
        }
        /** @description (empty) */
        recordingRuleResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['RecordingRuleJSON']
            }
        }
        /** @description (empty) */
        recordingRuleWriteTargetResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['PrometheusRemoteWriteTargetJSON']
            }
        }
        /** @description (empty) */
        refreshLicenseStatsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ActiveUserStats']
            }
        }
        /** @description (empty) */
        resourceDependenciesResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ResourceDependenciesResponseDTO']
            }
        }
        /** @description (empty) */
        resourcePermissionsDescription: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Description']
            }
        }
        /** @description (empty) */
        retrieveServiceAccountResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ServiceAccountDTO']
            }
        }
        /** @description (empty) */
        searchDashboardSnapshotsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['DashboardSnapshotDTO'][]
            }
        }
        /** @description (empty) */
        searchOrgServiceAccountsWithPagingResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['SearchOrgServiceAccountsResult']
            }
        }
        /** @description (empty) */
        searchOrgUsersResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['SearchOrgUsersQueryResult']
            }
        }
        /** @description (empty) */
        searchOrgsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['OrgDTO'][]
            }
        }
        /** @description (empty) */
        searchPlaylistsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['Playlists']
            }
        }
        /** @description (empty) */
        searchResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['HitList']
            }
        }
        /** @description (empty) */
        searchResultResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['SearchResult']
            }
        }
        /** @description (empty) */
        searchTeamsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['SearchTeamQueryResult']
            }
        }
        /** @description (empty) */
        searchUsersResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['UserSearchHitDTO'][]
            }
        }
        /** @description (empty) */
        searchUsersWithPagingResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['SearchUserQueryResult']
            }
        }
        /** @description (empty) */
        setRoleAssignmentsResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['RoleAssignmentsDTO']
            }
        }
        /** @description (empty) */
        snapshotListResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['SnapshotListResponseDTO']
            }
        }
        /** @description StatusMovedPermanently */
        statusMovedPermanently: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ErrorResponseBody']
            }
        }
        /** @description UnauthorizedError is returned when the request is not authenticated. */
        unauthorisedError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ErrorResponseBody']
            }
        }
        /** @description UnauthorisedPublicError is returned when the request is not authenticated. */
        unauthorisedPublicError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['publicError']
            }
        }
        /** @description UnprocessableEntityError */
        unprocessableEntityError: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['ErrorResponseBody']
            }
        }
        /** @description (empty) */
        updateCorrelationResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['UpdateCorrelationResponseBody']
            }
        }
        /** @description (empty) */
        updatePlaylistResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['PlaylistDTO']
            }
        }
        /** @description (empty) */
        updatePublicDashboardResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['PublicDashboard']
            }
        }
        /** @description (empty) */
        updateServiceAccountResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    /** Format: int64 */
                    id: number
                    message: string
                    name: string
                    serviceaccount: components['schemas']['ServiceAccountProfileDTO']
                }
            }
        }
        /** @description (empty) */
        updateTeamLBACRulesResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': {
                    /** Format: int64 */
                    id: number
                    message: string
                    name: string
                    rules: components['schemas']['TeamLBACRule'][]
                    uid: string
                }
            }
        }
        /** @description (empty) */
        userResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['UserProfileDTO']
            }
        }
        /** @description (empty) */
        viewPublicDashboardResponse: {
            headers: {
                [name: string]: unknown
            }
            content: {
                'application/json': components['schemas']['DashboardFullWithMeta']
            }
        }
    }
    parameters: never
    requestBodies: never
    headers: never
    pathItems: never
}
export type $defs = Record<string, never>
export interface operations {
    searchResult: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['searchResultResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    listRoles: {
        parameters: {
            query?: {
                delegatable?: boolean
                includeHidden?: boolean
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['listRolesResponse']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    createRole: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CreateRoleForm']
            }
        }
        responses: {
            201: components['responses']['createRoleResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getRole: {
        parameters: {
            query?: never
            header?: never
            path: {
                roleUID: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getRoleResponse']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    updateRole: {
        parameters: {
            query?: never
            header?: never
            path: {
                roleUID: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateRoleCommand']
            }
        }
        responses: {
            200: components['responses']['getRoleResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    deleteRole: {
        parameters: {
            query?: {
                force?: boolean
                global?: boolean
            }
            header?: never
            path: {
                roleUID: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getRoleAssignments: {
        parameters: {
            query?: never
            header?: never
            path: {
                roleUID: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getRoleAssignmentsResponse']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    setRoleAssignments: {
        parameters: {
            query?: never
            header?: never
            path: {
                roleUID: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['SetRoleAssignmentsCommand']
            }
        }
        responses: {
            200: components['responses']['setRoleAssignmentsResponse']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getAccessControlStatus: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getAccessControlStatusResponse']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    listTeamsRoles: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['RolesSearchQuery']
            }
        }
        responses: {
            200: components['responses']['listTeamsRolesResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    listTeamRoles: {
        parameters: {
            query?: never
            header?: never
            path: {
                teamId: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    setTeamRoles: {
        parameters: {
            query?: never
            header?: never
            path: {
                teamId: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    addTeamRole: {
        parameters: {
            query?: never
            header?: never
            path: {
                teamId: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['AddTeamRoleCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    removeTeamRole: {
        parameters: {
            query?: never
            header?: never
            path: {
                roleUID: string
                teamId: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    listUsersRoles: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['RolesSearchQuery']
            }
        }
        responses: {
            200: components['responses']['listUsersRolesResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    listUserRoles: {
        parameters: {
            query?: never
            header?: never
            path: {
                userId: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getAllRolesResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    setUserRoles: {
        parameters: {
            query?: never
            header?: never
            path: {
                userId: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['SetUserRolesCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    addUserRole: {
        parameters: {
            query?: never
            header?: never
            path: {
                userId: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['AddUserRoleCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    removeUserRole: {
        parameters: {
            query?: {
                /** @description A flag indicating if the assignment is global or not. If set to false, the default org ID of the authenticated user will be used from the request to remove assignment. */
                global?: boolean
            }
            header?: never
            path: {
                roleUID: string
                userId: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getResourceDescription: {
        parameters: {
            query?: never
            header?: never
            path: {
                resource: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['resourcePermissionsDescription']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getResourcePermissions: {
        parameters: {
            query?: never
            header?: never
            path: {
                resource: string
                resourceID: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getResourcePermissionsResponse']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    setResourcePermissions: {
        parameters: {
            query?: never
            header?: never
            path: {
                resource: string
                resourceID: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['setPermissionsCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    setResourcePermissionsForBuiltInRole: {
        parameters: {
            query?: never
            header?: never
            path: {
                resource: string
                resourceID: string
                builtInRole: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['setPermissionCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    setResourcePermissionsForTeam: {
        parameters: {
            query?: never
            header?: never
            path: {
                resource: string
                resourceID: string
                teamID: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['setPermissionCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    setResourcePermissionsForUser: {
        parameters: {
            query?: never
            header?: never
            path: {
                resource: string
                resourceID: string
                userID: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['setPermissionCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getSyncStatus: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getSyncStatusResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    reloadLDAPCfg: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getLDAPStatus: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    postSyncUserWithLDAP: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getUserFromLDAP: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_name: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    adminProvisioningReloadAccessControl: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            202: components['responses']['acceptedResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
        }
    }
    adminProvisioningReloadDashboards: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    adminProvisioningReloadDatasources: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    adminProvisioningReloadPlugins: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    adminGetSettings: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['adminGetSettingsResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
        }
    }
    adminGetStats: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['adminGetStatsResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    adminCreateUser: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['AdminCreateUserForm']
            }
        }
        responses: {
            200: components['responses']['adminCreateUserResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            412: components['responses']['preconditionFailedError']
            500: components['responses']['internalServerError']
        }
    }
    adminDeleteUser: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    adminGetUserAuthTokens: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['adminGetUserAuthTokensResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    adminDisableUser: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    adminEnableUser: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    adminLogoutUser: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    adminUpdateUserPassword: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['AdminUpdateUserPasswordForm']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    adminUpdateUserPermissions: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['AdminUpdateUserPermissionsForm']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getUserQuota: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getQuotaResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateUserQuota: {
        parameters: {
            query?: never
            header?: never
            path: {
                quota_target: string
                user_id: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateQuotaCmd']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    adminRevokeUserAuthToken: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['RevokeAuthTokenCmd']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getAnnotations: {
        parameters: {
            query?: {
                /** @description Find annotations created after specific epoch datetime in milliseconds. */
                from?: number
                /** @description Find annotations created before specific epoch datetime in milliseconds. */
                to?: number
                /** @description Limit response to annotations created by specific user. */
                userId?: number
                /** @description Find annotations for a specified alert rule by its ID.
                 *     deprecated: AlertID is deprecated and will be removed in future versions. Please use AlertUID instead. */
                alertId?: number
                /** @description Find annotations for a specified alert rule by its UID. */
                alertUID?: string
                /** @description Find annotations that are scoped to a specific dashboard */
                dashboardId?: number
                /** @description Find annotations that are scoped to a specific dashboard */
                dashboardUID?: string
                /** @description Find annotations that are scoped to a specific panel */
                panelId?: number
                /** @description Max limit for results returned. */
                limit?: number
                /** @description Use this to filter organization annotations. Organization annotations are annotations from an annotation data source that are not connected specifically to a dashboard or panel. You can filter by multiple tags. */
                tags?: string[]
                /** @description Return alerts or user created annotations */
                type?: 'alert' | 'annotation'
                /** @description Match any or all tags */
                matchAny?: boolean
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getAnnotationsResponse']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    postAnnotation: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['PostAnnotationsCmd']
            }
        }
        responses: {
            200: components['responses']['postAnnotationResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    postGraphiteAnnotation: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['PostGraphiteAnnotationsCmd']
            }
        }
        responses: {
            200: components['responses']['postAnnotationResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    massDeleteAnnotations: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['MassDeleteAnnotationsCmd']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    getAnnotationTags: {
        parameters: {
            query?: {
                /** @description Tag is a string that you can use to filter tags. */
                tag?: string
                /** @description Max limit for results returned. */
                limit?: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getAnnotationTagsResponse']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    getAnnotationByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                annotation_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getAnnotationByIDResponse']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    updateAnnotation: {
        parameters: {
            query?: never
            header?: never
            path: {
                annotation_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateAnnotationsCmd']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    deleteAnnotationByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                annotation_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    patchAnnotation: {
        parameters: {
            query?: never
            header?: never
            path: {
                annotation_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['PatchAnnotationsCmd']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getAPIkeys: {
        parameters: {
            query?: {
                /** @description Show expired keys */
                includeExpired?: boolean
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getAPIkeyResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    addAPIkey: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            410: components['responses']['goneError']
        }
    }
    deleteAPIkey: {
        parameters: {
            query?: never
            header?: never
            path: {
                id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getSessionList: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['cloudMigrationSessionListResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    createSession: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CloudMigrationSessionRequestDTO']
            }
        }
        responses: {
            200: components['responses']['cloudMigrationSessionResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getSession: {
        parameters: {
            query?: never
            header?: never
            path: {
                /** @description UID of a migration session */
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['cloudMigrationSessionResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    deleteSession: {
        parameters: {
            query?: never
            header?: never
            path: {
                /** @description UID of a migration session */
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    createSnapshot: {
        parameters: {
            query?: never
            header?: never
            path: {
                /** @description UID of a session */
                uid: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CreateSnapshotRequestDTO']
            }
        }
        responses: {
            200: components['responses']['createSnapshotResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getSnapshot: {
        parameters: {
            query?: {
                /** @description ResultPage is used for pagination with ResultLimit */
                resultPage?: number
                /** @description Max limit for snapshot results returned. */
                resultLimit?: number
                /** @description ResultSortColumn can be used to override the default system sort. Valid values are "name", "resource_type", and "status". */
                resultSortColumn?: string
                /** @description ResultSortOrder is used with ResultSortColumn. Valid values are ASC and DESC. */
                resultSortOrder?: string
                /** @description ErrorsOnly is used to only return resources with error statuses */
                errorsOnly?: boolean
            }
            header?: never
            path: {
                /** @description Session UID of a session */
                uid: string
                /** @description UID of a snapshot */
                snapshotUid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getSnapshotResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    cancelSnapshot: {
        parameters: {
            query?: never
            header?: never
            path: {
                /** @description Session UID of a session */
                uid: string
                /** @description UID of a snapshot */
                snapshotUid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description (empty) */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    uploadSnapshot: {
        parameters: {
            query?: never
            header?: never
            path: {
                /** @description Session UID of a session */
                uid: string
                /** @description UID of a snapshot */
                snapshotUid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description (empty) */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getShapshotList: {
        parameters: {
            query?: {
                /** @description Page is used for pagination with limit */
                page?: number
                /** @description Max limit for results returned. */
                limit?: number
                /** @description Sort with value latest to return results sorted in descending order. */
                sort?: string
            }
            header?: never
            path: {
                /** @description Session UID of a session */
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['snapshotListResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getResourceDependencies: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['resourceDependenciesResponse']
        }
    }
    getCloudMigrationToken: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['cloudMigrationGetTokenResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    createCloudMigrationToken: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['cloudMigrationCreateTokenResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    deleteCloudMigrationToken: {
        parameters: {
            query?: never
            header?: never
            path: {
                /** @description UID of a cloud migration token */
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            204: components['responses']['cloudMigrationDeleteTokenResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    searchDashboardSnapshots: {
        parameters: {
            query?: {
                /** @description Search Query */
                query?: string
                /** @description Limit the number of returned results */
                limit?: number
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['searchDashboardSnapshotsResponse']
            500: components['responses']['internalServerError']
        }
    }
    calculateDashboardDiff: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': {
                    base: components['schemas']['CalculateDiffTarget']
                    /**
                     * @description The type of diff to return
                     *     Description:
                     *     `basic`
                     *     `json`
                     * @enum {string}
                     */
                    diffType: 'basic' | 'json'
                    new: components['schemas']['CalculateDiffTarget']
                }
            }
        }
        responses: {
            200: components['responses']['calculateDashboardDiffResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    postDashboard: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['SaveDashboardCommand']
            }
        }
        responses: {
            200: components['responses']['postDashboardResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            412: components['responses']['preconditionFailedError']
            422: components['responses']['unprocessableEntityError']
            500: components['responses']['internalServerError']
        }
    }
    getHomeDashboard: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getHomeDashboardResponse']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    getDashboardPermissionsListByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                DashboardID: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getDashboardPermissionsListResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateDashboardPermissionsByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                DashboardID: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateDashboardACLCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    restoreDashboardVersionByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                DashboardID: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['RestoreDashboardVersionCommand']
            }
        }
        responses: {
            200: components['responses']['postDashboardResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getDashboardVersionsByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                DashboardID: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['dashboardVersionsResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getDashboardVersionByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                DashboardID: number
                DashboardVersionID: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['dashboardVersionResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    importDashboard: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['ImportDashboardRequest']
            }
        }
        responses: {
            200: components['responses']['importDashboardResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            412: components['responses']['preconditionFailedError']
            422: components['responses']['unprocessableEntityError']
            500: components['responses']['internalServerError']
        }
    }
    listPublicDashboards: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['listPublicDashboardsResponse']
            401: components['responses']['unauthorisedPublicError']
            403: components['responses']['forbiddenPublicError']
            500: components['responses']['internalServerPublicError']
        }
    }
    getDashboardTags: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getDashboardsTagsResponse']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    getPublicDashboard: {
        parameters: {
            query?: never
            header?: never
            path: {
                dashboardUid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getPublicDashboardResponse']
            400: components['responses']['badRequestPublicError']
            401: components['responses']['unauthorisedPublicError']
            403: components['responses']['forbiddenPublicError']
            404: components['responses']['notFoundPublicError']
            500: components['responses']['internalServerPublicError']
        }
    }
    createPublicDashboard: {
        parameters: {
            query?: never
            header?: never
            path: {
                dashboardUid: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['PublicDashboardDTO']
            }
        }
        responses: {
            200: components['responses']['createPublicDashboardResponse']
            400: components['responses']['badRequestPublicError']
            401: components['responses']['unauthorisedPublicError']
            403: components['responses']['forbiddenPublicError']
            500: components['responses']['internalServerPublicError']
        }
    }
    deletePublicDashboard: {
        parameters: {
            query?: never
            header?: never
            path: {
                dashboardUid: string
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestPublicError']
            401: components['responses']['unauthorisedPublicError']
            403: components['responses']['forbiddenPublicError']
            500: components['responses']['internalServerPublicError']
        }
    }
    updatePublicDashboard: {
        parameters: {
            query?: never
            header?: never
            path: {
                dashboardUid: string
                uid: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['PublicDashboardDTO']
            }
        }
        responses: {
            200: components['responses']['updatePublicDashboardResponse']
            400: components['responses']['badRequestPublicError']
            401: components['responses']['unauthorisedPublicError']
            403: components['responses']['forbiddenPublicError']
            500: components['responses']['internalServerPublicError']
        }
    }
    getDashboardByUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['dashboardResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            406: components['responses']['notAcceptableError']
            500: components['responses']['internalServerError']
        }
    }
    deleteDashboardByUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['deleteDashboardResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getDashboardPermissionsListByUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getDashboardPermissionsListResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateDashboardPermissionsByUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateDashboardACLCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    restoreDashboardVersionByUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['RestoreDashboardVersionCommand']
            }
        }
        responses: {
            200: components['responses']['postDashboardResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getDashboardVersionsByUID: {
        parameters: {
            query?: {
                /** @description Maximum number of results to return */
                limit?: number
                /** @description Version to start from when returning queries */
                start?: number
            }
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['dashboardVersionsResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getDashboardVersionByUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                DashboardVersionID: number
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['dashboardVersionResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getDataSources: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getDataSourcesResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    addDataSource: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['AddDataSourceCommand']
            }
        }
        responses: {
            200: components['responses']['createOrUpdateDatasourceResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            409: components['responses']['conflictError']
            500: components['responses']['internalServerError']
        }
    }
    getCorrelations: {
        parameters: {
            query?: {
                /** @description Limit the maximum number of correlations to return per page */
                limit?: number
                /** @description Page index for starting fetching correlations */
                page?: number
                /** @description Source datasource UID filter to be applied to correlations */
                sourceUID?: string[]
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getCorrelationsResponse']
            401: components['responses']['unauthorisedError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getDataSourceIdByName: {
        parameters: {
            query?: never
            header?: never
            path: {
                name: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getDataSourceIDResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getDataSourceByName: {
        parameters: {
            query?: never
            header?: never
            path: {
                name: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getDataSourceResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    deleteDataSourceByName: {
        parameters: {
            query?: never
            header?: never
            path: {
                name: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['deleteDataSourceByNameResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    datasourceProxyGETByUIDcalls: {
        parameters: {
            query?: never
            header?: never
            path: {
                datasource_proxy_route: string
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description (empty) */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    datasourceProxyPOSTByUIDcalls: {
        parameters: {
            query?: never
            header?: never
            path: {
                datasource_proxy_route: string
                uid: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': unknown
            }
        }
        responses: {
            /** @description (empty) */
            201: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            /** @description (empty) */
            202: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    datasourceProxyDELETEByUIDcalls: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
                datasource_proxy_route: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description (empty) */
            202: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    datasourceProxyGETcalls: {
        parameters: {
            query?: never
            header?: never
            path: {
                datasource_proxy_route: string
                id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description (empty) */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    datasourceProxyPOSTcalls: {
        parameters: {
            query?: never
            header?: never
            path: {
                datasource_proxy_route: string
                id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': unknown
            }
        }
        responses: {
            /** @description (empty) */
            201: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            /** @description (empty) */
            202: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    datasourceProxyDELETEcalls: {
        parameters: {
            query?: never
            header?: never
            path: {
                id: string
                datasource_proxy_route: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description (empty) */
            202: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getCorrelationsBySourceUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                sourceUID: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getCorrelationsBySourceUIDResponse']
            401: components['responses']['unauthorisedError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    createCorrelation: {
        parameters: {
            query?: never
            header?: never
            path: {
                sourceUID: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CreateCorrelationCommand']
            }
        }
        responses: {
            200: components['responses']['createCorrelationResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getCorrelation: {
        parameters: {
            query?: never
            header?: never
            path: {
                sourceUID: string
                correlationUID: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getCorrelationResponse']
            401: components['responses']['unauthorisedError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateCorrelation: {
        parameters: {
            query?: never
            header?: never
            path: {
                sourceUID: string
                correlationUID: string
            }
            cookie?: never
        }
        requestBody?: {
            content: {
                'application/json': components['schemas']['UpdateCorrelationCommand']
            }
        }
        responses: {
            200: components['responses']['updateCorrelationResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getDataSourceByUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getDataSourceResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateDataSourceByUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateDataSourceCommand']
            }
        }
        responses: {
            200: components['responses']['createOrUpdateDatasourceResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            409: components['responses']['conflictError']
            500: components['responses']['internalServerError']
        }
    }
    deleteDataSourceByUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    deleteCorrelation: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
                correlationUID: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['deleteCorrelationResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    checkDatasourceHealthWithUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getTeamLBACRulesApi: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getTeamLBACRulesResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateTeamLBACRulesApi: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody?: {
            content: {
                'application/json': components['schemas']['UpdateTeamLBACCommand']
            }
        }
        responses: {
            200: components['responses']['updateTeamLBACRulesResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    callDatasourceResourceWithUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                datasource_proxy_route: string
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getDataSourceCacheConfig: {
        parameters: {
            query?: never
            header?: never
            path: {
                dataSourceUID: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description CacheConfigResponse */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['CacheConfigResponse']
                }
            }
            500: components['responses']['internalServerError']
        }
    }
    setDataSourceCacheConfig: {
        parameters: {
            query?: never
            header?: never
            path: {
                dataSourceUID: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CacheConfigSetter']
            }
        }
        responses: {
            /** @description CacheConfigResponse */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['CacheConfigResponse']
                }
            }
            400: components['responses']['badRequestError']
            500: components['responses']['internalServerError']
        }
    }
    cleanDataSourceCache: {
        parameters: {
            query?: never
            header?: never
            path: {
                dataSourceUID: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description CacheConfigResponse */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['CacheConfigResponse']
                }
            }
            500: components['responses']['internalServerError']
        }
    }
    disableDataSourceCache: {
        parameters: {
            query?: never
            header?: never
            path: {
                dataSourceUID: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description CacheConfigResponse */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['CacheConfigResponse']
                }
            }
            500: components['responses']['internalServerError']
        }
    }
    enableDataSourceCache: {
        parameters: {
            query?: never
            header?: never
            path: {
                dataSourceUID: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description CacheConfigResponse */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['CacheConfigResponse']
                }
            }
            500: components['responses']['internalServerError']
        }
    }
    getDataSourceByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getDataSourceResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateDataSourceByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateDataSourceCommand']
            }
        }
        responses: {
            200: components['responses']['createOrUpdateDatasourceResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    deleteDataSourceByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    checkDatasourceHealthByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    callDatasourceResourceByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                datasource_proxy_route: string
                id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    queryMetricsWithExpressions: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['MetricRequest']
            }
        }
        responses: {
            200: components['responses']['queryMetricsWithExpressionsRespons']
            207: components['responses']['queryMetricsWithExpressionsRespons']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getFolders: {
        parameters: {
            query?: {
                /** @description Limit the maximum number of folders to return */
                limit?: number
                /** @description Page index for starting fetching folders */
                page?: number
                /** @description The parent folder UID */
                parentUid?: string
                /** @description Set to `Edit` to return folders that the user can edit */
                permission?: 'Edit' | 'View'
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getFoldersResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    createFolder: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CreateFolderCommand']
            }
        }
        responses: {
            200: components['responses']['folderResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            409: components['responses']['conflictError']
            500: components['responses']['internalServerError']
        }
    }
    getFolderByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                folder_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['folderResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getFolderByUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                folder_uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['folderResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateFolder: {
        parameters: {
            query?: never
            header?: never
            path: {
                folder_uid: string
            }
            cookie?: never
        }
        /** @description To change the unique identifier (uid), provide another one.
         *     To overwrite an existing folder with newer version, set `overwrite` to `true`.
         *     Provide the current version to safelly update the folder: if the provided version differs from the stored one the request will fail, unless `overwrite` is `true`. */
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateFolderCommand']
            }
        }
        responses: {
            200: components['responses']['folderResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            409: components['responses']['conflictError']
            500: components['responses']['internalServerError']
        }
    }
    deleteFolder: {
        parameters: {
            query?: {
                /** @description If `true` any Grafana 8 Alerts under this folder will be deleted.
                 *     Set to `false` so that the request will fail if the folder contains any Grafana 8 Alerts. */
                forceDeleteRules?: boolean
            }
            header?: never
            path: {
                folder_uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['deleteFolderResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getFolderDescendantCounts: {
        parameters: {
            query?: never
            header?: never
            path: {
                folder_uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getFolderDescendantCountsResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    moveFolder: {
        parameters: {
            query?: never
            header?: never
            path: {
                folder_uid: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['MoveFolderCommand']
            }
        }
        responses: {
            200: components['responses']['folderResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getFolderPermissionList: {
        parameters: {
            query?: never
            header?: never
            path: {
                folder_uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getFolderPermissionListResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateFolderPermissions: {
        parameters: {
            query?: never
            header?: never
            path: {
                folder_uid: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateDashboardACLCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getMappedGroups: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getGroupsResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    updateGroupMappings: {
        parameters: {
            query?: never
            header?: never
            path: {
                group_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['GroupAttributes']
            }
        }
        responses: {
            201: components['responses']['apiResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    createGroupMappings: {
        parameters: {
            query?: never
            header?: never
            path: {
                group_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['GroupAttributes']
            }
        }
        responses: {
            201: components['responses']['apiResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    deleteGroupMappings: {
        parameters: {
            query?: never
            header?: never
            path: {
                group_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            204: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getGroupRoles: {
        parameters: {
            query?: never
            header?: never
            path: {
                group_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getGroupRolesResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getHealth: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description healthResponse */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['healthResponse']
                }
            }
            503: components['responses']['internalServerError']
        }
    }
    getLibraryElements: {
        parameters: {
            query?: {
                /** @description Part of the name or description searched for. */
                searchString?: string
                /** @description Kind of element to search for. */
                kind?: 1 | 2
                /** @description Sort order of elements. */
                sortDirection?: 'alpha-asc' | 'alpha-desc'
                /** @description A comma separated list of types to filter the elements by */
                typeFilter?: string
                /** @description Element UID to exclude from search results. */
                excludeUid?: string
                /** @description A comma separated list of folder ID(s) to filter the elements by. */
                folderFilter?: string
                /** @description The number of results per page. */
                perPage?: number
                /** @description The page for a set of records, given that only perPage records are returned at a time. Numbering starts at 1. */
                page?: number
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getLibraryElementsResponse']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    createLibraryElement: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CreateLibraryElementCommand']
            }
        }
        responses: {
            200: components['responses']['getLibraryElementResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getLibraryElementByName: {
        parameters: {
            query?: never
            header?: never
            path: {
                library_element_name: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getLibraryElementArrayResponse']
            401: components['responses']['unauthorisedError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getLibraryElementByUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                library_element_uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getLibraryElementResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    deleteLibraryElementByUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                library_element_uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateLibraryElement: {
        parameters: {
            query?: never
            header?: never
            path: {
                library_element_uid: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['PatchLibraryElementCommand']
            }
        }
        responses: {
            200: components['responses']['getLibraryElementResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            412: components['responses']['preconditionFailedError']
            500: components['responses']['internalServerError']
        }
    }
    getLibraryElementConnections: {
        parameters: {
            query?: never
            header?: never
            path: {
                library_element_uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getLibraryElementConnectionsResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getStatus: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getStatusResponse']
        }
    }
    getCustomPermissionsReport: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            500: components['responses']['internalServerError']
        }
    }
    getCustomPermissionsCSV: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            500: components['responses']['internalServerError']
        }
    }
    refreshLicenseStats: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['refreshLicenseStatsResponse']
            500: components['responses']['internalServerError']
        }
    }
    getLicenseToken: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getLicenseTokenResponse']
        }
    }
    postLicenseToken: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['DeleteTokenCommand']
            }
        }
        responses: {
            200: components['responses']['getLicenseTokenResponse']
            400: components['responses']['badRequestError']
        }
    }
    deleteLicenseToken: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['DeleteTokenCommand']
            }
        }
        responses: {
            202: components['responses']['acceptedResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            422: components['responses']['unprocessableEntityError']
            500: components['responses']['internalServerError']
        }
    }
    postRenewLicenseToken: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': Record<string, never>
            }
        }
        responses: {
            200: components['responses']['postRenewLicenseTokenResponse']
            401: components['responses']['unauthorisedError']
            404: components['responses']['notFoundError']
        }
    }
    getSAMLLogout: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description (empty) */
            302: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getCurrentOrg: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getCurrentOrgResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    updateCurrentOrg: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateOrgForm']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    updateCurrentOrgAddress: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateOrgAddressForm']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getPendingOrgInvites: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getPendingOrgInvitesResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    addOrgInvite: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['AddInviteForm']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            412: components['responses']['SMTPNotEnabledError']
            500: components['responses']['internalServerError']
        }
    }
    revokeInvite: {
        parameters: {
            query?: never
            header?: never
            path: {
                invitation_code: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getOrgPreferences: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getPreferencesResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    updateOrgPreferences: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdatePrefsCmd']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    patchOrgPreferences: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['PatchPrefsCmd']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getCurrentOrgQuota: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getQuotaResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getOrgUsersForCurrentOrg: {
        parameters: {
            query?: {
                query?: string
                limit?: number
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getOrgUsersForCurrentOrgResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    addOrgUserToCurrentOrg: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['AddOrgUserCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getOrgUsersForCurrentOrgLookup: {
        parameters: {
            query?: {
                query?: string
                limit?: number
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getOrgUsersForCurrentOrgLookupResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    removeOrgUserForCurrentOrg: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    updateOrgUserForCurrentOrg: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateOrgUserCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    searchOrgs: {
        parameters: {
            query?: {
                page?: number
                /** @description Number of items per page
                 *     The totalCount field in the response can be used for pagination list E.g. if totalCount is equal to 100 teams and the perpage parameter is set to 10 then there are 10 pages of teams. */
                perpage?: number
                name?: string
                /** @description If set it will return results where the query value is contained in the name field. Query values with spaces need to be URL encoded. */
                query?: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['searchOrgsResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            409: components['responses']['conflictError']
            500: components['responses']['internalServerError']
        }
    }
    createOrg: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CreateOrgCommand']
            }
        }
        responses: {
            200: components['responses']['createOrgResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            409: components['responses']['conflictError']
            500: components['responses']['internalServerError']
        }
    }
    getOrgByName: {
        parameters: {
            query?: never
            header?: never
            path: {
                org_name: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getOrgByNameResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getOrgByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                org_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getOrgByIDResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    updateOrg: {
        parameters: {
            query?: never
            header?: never
            path: {
                org_id: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateOrgForm']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    deleteOrgByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                org_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateOrgAddress: {
        parameters: {
            query?: never
            header?: never
            path: {
                org_id: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateOrgAddressForm']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getOrgQuota: {
        parameters: {
            query?: never
            header?: never
            path: {
                org_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getQuotaResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateOrgQuota: {
        parameters: {
            query?: never
            header?: never
            path: {
                quota_target: string
                org_id: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateQuotaCmd']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getOrgUsers: {
        parameters: {
            query?: never
            header?: never
            path: {
                org_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getOrgUsersResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    addOrgUser: {
        parameters: {
            query?: never
            header?: never
            path: {
                org_id: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['AddOrgUserCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    searchOrgUsers: {
        parameters: {
            query?: never
            header?: never
            path: {
                org_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['searchOrgUsersResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    removeOrgUser: {
        parameters: {
            query?: never
            header?: never
            path: {
                org_id: number
                user_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    updateOrgUser: {
        parameters: {
            query?: never
            header?: never
            path: {
                org_id: number
                user_id: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateOrgUserCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    searchPlaylists: {
        parameters: {
            query?: {
                query?: string
                /** @description in:limit */
                limit?: number
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['searchPlaylistsResponse']
            500: components['responses']['internalServerError']
        }
    }
    createPlaylist: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CreatePlaylistCommand']
            }
        }
        responses: {
            200: components['responses']['createPlaylistResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getPlaylist: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getPlaylistResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updatePlaylist: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdatePlaylistCommand']
            }
        }
        responses: {
            200: components['responses']['updatePlaylistResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    deletePlaylist: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getPlaylistItems: {
        parameters: {
            query?: never
            header?: never
            path: {
                uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getPlaylistItemsResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    viewPublicDashboard: {
        parameters: {
            query?: never
            header?: never
            path: {
                accessToken: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['viewPublicDashboardResponse']
            400: components['responses']['badRequestPublicError']
            401: components['responses']['unauthorisedPublicError']
            403: components['responses']['forbiddenPublicError']
            404: components['responses']['notFoundPublicError']
            500: components['responses']['internalServerPublicError']
        }
    }
    getPublicAnnotations: {
        parameters: {
            query?: never
            header?: never
            path: {
                accessToken: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getPublicAnnotationsResponse']
            400: components['responses']['badRequestPublicError']
            401: components['responses']['unauthorisedPublicError']
            403: components['responses']['forbiddenPublicError']
            404: components['responses']['notFoundPublicError']
            500: components['responses']['internalServerPublicError']
        }
    }
    queryPublicDashboard: {
        parameters: {
            query?: never
            header?: never
            path: {
                accessToken: string
                panelId: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['queryPublicDashboardResponse']
            400: components['responses']['badRequestPublicError']
            401: components['responses']['unauthorisedPublicError']
            403: components['responses']['forbiddenPublicError']
            404: components['responses']['notFoundPublicError']
            500: components['responses']['internalServerPublicError']
        }
    }
    searchQueries: {
        parameters: {
            query?: {
                /** @description List of data source UIDs to search for */
                datasourceUid?: string[]
                /** @description Text inside query or comments that is searched for */
                searchString?: string
                /** @description Flag indicating if only starred queries should be returned */
                onlyStarred?: boolean
                /** @description Sort method */
                sort?: 'time-desc' | 'time-asc'
                /** @description Use this parameter to access hits beyond limit. Numbering starts at 1. limit param acts as page size. */
                page?: number
                /** @description Limit the number of returned results */
                limit?: number
                /** @description From range for the query history search */
                from?: number
                /** @description To range for the query history search */
                to?: number
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getQueryHistorySearchResponse']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    createQuery: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CreateQueryInQueryHistoryCommand']
            }
        }
        responses: {
            200: components['responses']['getQueryHistoryResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    starQuery: {
        parameters: {
            query?: never
            header?: never
            path: {
                query_history_uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getQueryHistoryResponse']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    unstarQuery: {
        parameters: {
            query?: never
            header?: never
            path: {
                query_history_uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getQueryHistoryResponse']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    deleteQuery: {
        parameters: {
            query?: never
            header?: never
            path: {
                query_history_uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getQueryHistoryDeleteQueryResponse']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    patchQueryComment: {
        parameters: {
            query?: never
            header?: never
            path: {
                query_history_uid: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['PatchQueryCommentInQueryHistoryCommand']
            }
        }
        responses: {
            200: components['responses']['getQueryHistoryResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    listRecordingRules: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['listRecordingRulesResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateRecordingRule: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['RecordingRuleJSON']
            }
        }
        responses: {
            200: components['responses']['recordingRuleResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    createRecordingRule: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['RecordingRuleJSON']
            }
        }
        responses: {
            200: components['responses']['recordingRuleResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    testCreateRecordingRule: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['RecordingRuleJSON']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            422: components['responses']['unprocessableEntityError']
            500: components['responses']['internalServerError']
        }
    }
    getRecordingRuleWriteTarget: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['recordingRuleWriteTargetResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    createRecordingRuleWriteTarget: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['PrometheusRemoteWriteTargetJSON']
            }
        }
        responses: {
            200: components['responses']['recordingRuleWriteTargetResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            422: components['responses']['unprocessableEntityError']
            500: components['responses']['internalServerError']
        }
    }
    deleteRecordingRuleWriteTarget: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    deleteRecordingRule: {
        parameters: {
            query?: never
            header?: never
            path: {
                recordingRuleID: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getReports: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getReportsResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    createReport: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CreateOrUpdateReport']
            }
        }
        responses: {
            200: components['responses']['createReportResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    sendReport: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['ReportEmail']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getSettingsImage: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['contentResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    renderReportCSVs: {
        parameters: {
            query?: {
                dashboards?: string
                title?: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['contentResponse']
            204: components['responses']['noContentResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    renderReportPDFs: {
        parameters: {
            query?: {
                dashboards?: string
                orientation?: string
                layout?: string
                title?: string
                scaleFactor?: string
                includeTables?: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['contentResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    getReportSettings: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getReportSettingsResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    saveReportSettings: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['ReportSettings']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    sendTestEmail: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CreateOrUpdateReport']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getReport: {
        parameters: {
            query?: never
            header?: never
            path: {
                id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getReportResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateReport: {
        parameters: {
            query?: never
            header?: never
            path: {
                id: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CreateOrUpdateReport']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    deleteReport: {
        parameters: {
            query?: never
            header?: never
            path: {
                id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    postACS: {
        parameters: {
            query?: {
                RelayState?: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description (empty) */
            302: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getMetadata: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['contentResponse']
        }
    }
    getSLO: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description (empty) */
            302: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    postSLO: {
        parameters: {
            query?: {
                SAMLRequest?: string
                SAMLResponse?: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description (empty) */
            302: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            400: components['responses']['badRequestError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    search: {
        parameters: {
            query?: {
                /** @description Search Query */
                query?: string
                /** @description List of tags to search for */
                tag?: string[]
                /** @description Type to search for, dash-folder or dash-db */
                type?: 'dash-folder' | 'dash-db'
                /** @description List of dashboard id’s to search for
                 *     This is deprecated: users should use the `dashboardUIDs` query parameter instead */
                dashboardIds?: number[]
                /** @description List of dashboard uid’s to search for */
                dashboardUIDs?: string[]
                /** @description List of folder id’s to search in for dashboards
                 *     If it's `0` then it will query for the top level folders
                 *     This is deprecated: users should use the `folderUIDs` query parameter instead */
                folderIds?: number[]
                /** @description List of folder UID’s to search in for dashboards
                 *     If it's an empty string then it will query for the top level folders */
                folderUIDs?: string[]
                /** @description Flag indicating if only starred Dashboards should be returned */
                starred?: boolean
                /** @description Limit the number of returned results (max 5000) */
                limit?: number
                /** @description Use this parameter to access hits beyond limit. Numbering starts at 1. limit param acts as page size. Only available in Grafana v6.2+. */
                page?: number
                /** @description Set to `Edit` to return dashboards/folders that the user can edit */
                permission?: 'Edit' | 'View'
                /** @description Sort method; for listing all the possible sort methods use the search sorting endpoint. */
                sort?: 'alpha-asc' | 'alpha-desc'
                /** @description Flag indicating if only soft deleted Dashboards should be returned */
                deleted?: boolean
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['searchResponse']
            401: components['responses']['unauthorisedError']
            422: components['responses']['unprocessableEntityError']
            500: components['responses']['internalServerError']
        }
    }
    SearchDevices: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['devicesSearchResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    listSortOptions: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['listSortOptionsResponse']
            401: components['responses']['unauthorisedError']
        }
    }
    createServiceAccount: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: {
            content: {
                'application/json': components['schemas']['CreateServiceAccountForm']
            }
        }
        responses: {
            201: components['responses']['createServiceAccountResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    searchOrgServiceAccountsWithPaging: {
        parameters: {
            query?: {
                Disabled?: boolean
                expiredTokens?: boolean
                /** @description It will return results where the query value is contained in one of the name.
                 *     Query values with spaces need to be URL encoded. */
                query?: string
                /** @description The default value is 1000. */
                perpage?: number
                /** @description The default value is 1. */
                page?: number
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['searchOrgServiceAccountsWithPagingResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    retrieveServiceAccount: {
        parameters: {
            query?: never
            header?: never
            path: {
                serviceAccountId: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['retrieveServiceAccountResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    deleteServiceAccount: {
        parameters: {
            query?: never
            header?: never
            path: {
                serviceAccountId: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    updateServiceAccount: {
        parameters: {
            query?: never
            header?: never
            path: {
                serviceAccountId: number
            }
            cookie?: never
        }
        requestBody?: {
            content: {
                'application/json': components['schemas']['UpdateServiceAccountForm']
            }
        }
        responses: {
            200: components['responses']['updateServiceAccountResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    listTokens: {
        parameters: {
            query?: never
            header?: never
            path: {
                serviceAccountId: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['listTokensResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    createToken: {
        parameters: {
            query?: never
            header?: never
            path: {
                serviceAccountId: number
            }
            cookie?: never
        }
        requestBody?: {
            content: {
                'application/json': components['schemas']['AddServiceAccountTokenCommand']
            }
        }
        responses: {
            200: components['responses']['createTokenResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            409: components['responses']['conflictError']
            500: components['responses']['internalServerError']
        }
    }
    deleteToken: {
        parameters: {
            query?: never
            header?: never
            path: {
                tokenId: number
                serviceAccountId: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    retrieveJWKS: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['jwksResponse']
            500: components['responses']['internalServerError']
        }
    }
    getSharingOptions: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getSharingOptionsResponse']
            401: components['responses']['unauthorisedError']
        }
    }
    createDashboardSnapshot: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CreateDashboardSnapshotCommand']
            }
        }
        responses: {
            200: components['responses']['createDashboardSnapshotResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    deleteDashboardSnapshotByDeleteKey: {
        parameters: {
            query?: never
            header?: never
            path: {
                deleteKey: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getDashboardSnapshot: {
        parameters: {
            query?: never
            header?: never
            path: {
                key: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getDashboardSnapshotResponse']
            400: components['responses']['badRequestError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    deleteDashboardSnapshot: {
        parameters: {
            query?: never
            header?: never
            path: {
                key: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    listDevices: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['devicesResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    createTeam: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CreateTeamCommand']
            }
        }
        responses: {
            200: components['responses']['createTeamResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            409: components['responses']['conflictError']
            500: components['responses']['internalServerError']
        }
    }
    searchTeams: {
        parameters: {
            query?: {
                page?: number
                /** @description Number of items per page
                 *     The totalCount field in the response can be used for pagination list E.g. if totalCount is equal to 100 teams and the perpage parameter is set to 10 then there are 10 pages of teams. */
                perpage?: number
                name?: string
                /** @description If set it will return results where the query value is contained in the name field. Query values with spaces need to be URL encoded. */
                query?: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['searchTeamsResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getTeamGroupsApi: {
        parameters: {
            query?: never
            header?: never
            path: {
                teamId: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getTeamGroupsApiResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    addTeamGroupApi: {
        parameters: {
            query?: never
            header?: never
            path: {
                teamId: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['TeamGroupMapping']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    removeTeamGroupApiQuery: {
        parameters: {
            query?: {
                groupId?: string
            }
            header?: never
            path: {
                teamId: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getTeamByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                team_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getTeamByIDResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateTeam: {
        parameters: {
            query?: never
            header?: never
            path: {
                team_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateTeamCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            409: components['responses']['conflictError']
            500: components['responses']['internalServerError']
        }
    }
    deleteTeamByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                team_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getTeamMembers: {
        parameters: {
            query?: never
            header?: never
            path: {
                team_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getTeamMembersResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    setTeamMemberships: {
        parameters: {
            query?: never
            header?: never
            path: {
                team_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['SetTeamMembershipsCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    addTeamMember: {
        parameters: {
            query?: never
            header?: never
            path: {
                team_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['AddTeamMemberCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateTeamMember: {
        parameters: {
            query?: never
            header?: never
            path: {
                team_id: string
                user_id: number
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateTeamMemberCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    removeTeamMember: {
        parameters: {
            query?: never
            header?: never
            path: {
                team_id: string
                user_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getTeamPreferences: {
        parameters: {
            query?: never
            header?: never
            path: {
                team_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getPreferencesResponse']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    updateTeamPreferences: {
        parameters: {
            query?: never
            header?: never
            path: {
                team_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdatePrefsCmd']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    getSignedInUser: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['userResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateSignedInUser: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description To change the email, name, login, theme, provide another one. */
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateUserCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            409: components['responses']['conflictError']
            500: components['responses']['internalServerError']
        }
    }
    getUserAuthTokens: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getUserAuthTokensResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    updateUserEmail: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            302: components['responses']['okResponse']
        }
    }
    clearHelpFlags: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['helpFlagResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    setHelpFlag: {
        parameters: {
            query?: never
            header?: never
            path: {
                flag_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['helpFlagResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getSignedInUserOrgList: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getSignedInUserOrgListResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    changeUserPassword: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description To change the email, name, login, theme, provide another one. */
        requestBody: {
            content: {
                'application/json': components['schemas']['ChangeUserPasswordCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getUserPreferences: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getPreferencesResponse']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    updateUserPreferences: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdatePrefsCmd']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    patchUserPreferences: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['PatchPrefsCmd']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            500: components['responses']['internalServerError']
        }
    }
    getUserQuotas: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getQuotaResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    revokeUserAuthToken: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['RevokeAuthTokenCmd']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    starDashboardByUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                dashboard_uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    unstarDashboardByUID: {
        parameters: {
            query?: never
            header?: never
            path: {
                dashboard_uid: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    starDashboard: {
        parameters: {
            query?: never
            header?: never
            path: {
                dashboard_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    unstarDashboard: {
        parameters: {
            query?: never
            header?: never
            path: {
                dashboard_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getSignedInUserTeamList: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getSignedInUserTeamListResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    userSetUsingOrg: {
        parameters: {
            query?: never
            header?: never
            path: {
                org_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    searchUsers: {
        parameters: {
            query?: {
                /** @description Limit the maximum number of users to return per page */
                perpage?: number
                /** @description Page index for starting fetching users */
                page?: number
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['searchUsersResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    getUserByLoginOrEmail: {
        parameters: {
            query: {
                /** @description loginOrEmail of the user */
                loginOrEmail: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['userResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    searchUsersWithPaging: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['searchUsersWithPagingResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getUserByID: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['userResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    updateUser: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        /** @description To change the email, name, login, theme, provide another one. */
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateUserCommand']
            }
        }
        responses: {
            200: components['responses']['okResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            409: components['responses']['conflictError']
            500: components['responses']['internalServerError']
        }
    }
    getUserOrgList: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getUserOrgListResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    getUserTeams: {
        parameters: {
            query?: never
            header?: never
            path: {
                user_id: number
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getUserTeamsResponse']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
    RouteGetAlertRules: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description ProvisionedAlertRules */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ProvisionedAlertRules']
                }
            }
        }
    }
    RoutePostAlertRule: {
        parameters: {
            query?: never
            header?: {
                'X-Disable-Provenance'?: string
            }
            path?: never
            cookie?: never
        }
        requestBody?: {
            content: {
                'application/json': components['schemas']['ProvisionedAlertRule']
            }
        }
        responses: {
            /** @description ProvisionedAlertRule */
            201: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ProvisionedAlertRule']
                }
            }
            /** @description ValidationError */
            400: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ValidationError']
                }
            }
        }
    }
    RouteGetAlertRulesExport: {
        parameters: {
            query?: {
                /** @description Whether to initiate a download of the file or not. */
                download?: boolean
                /** @description Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence. */
                format?: 'yaml' | 'json' | 'hcl'
                /** @description UIDs of folders from which to export rules */
                folderUid?: string[]
                /** @description Name of group of rules to export. Must be specified only together with a single folder UID */
                group?: string
                /** @description UID of alert rule to export. If specified, parameters folderUid and group must be empty. */
                ruleUid?: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description AlertingFileExport */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['AlertingFileExport']
                    'application/terraform+hcl': components['schemas']['AlertingFileExport']
                    'application/yaml': components['schemas']['AlertingFileExport']
                    'text/hcl': components['schemas']['AlertingFileExport']
                    'text/yaml': components['schemas']['AlertingFileExport']
                }
            }
            /** @description  Not found. */
            404: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
        }
    }
    RouteGetAlertRule: {
        parameters: {
            query?: never
            header?: never
            path: {
                /** @description Alert rule UID */
                UID: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description ProvisionedAlertRule */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ProvisionedAlertRule']
                }
            }
            /** @description  Not found. */
            404: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
        }
    }
    RoutePutAlertRule: {
        parameters: {
            query?: never
            header?: {
                'X-Disable-Provenance'?: string
            }
            path: {
                /** @description Alert rule UID */
                UID: string
            }
            cookie?: never
        }
        requestBody?: {
            content: {
                'application/json': components['schemas']['ProvisionedAlertRule']
            }
        }
        responses: {
            /** @description ProvisionedAlertRule */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ProvisionedAlertRule']
                }
            }
            /** @description ValidationError */
            400: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ValidationError']
                }
            }
        }
    }
    RouteDeleteAlertRule: {
        parameters: {
            query?: never
            header?: {
                'X-Disable-Provenance'?: string
            }
            path: {
                /** @description Alert rule UID */
                UID: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description  The alert rule was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
        }
    }
    RouteGetAlertRuleExport: {
        parameters: {
            query?: {
                /** @description Whether to initiate a download of the file or not. */
                download?: boolean
                /** @description Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence. */
                format?: 'yaml' | 'json' | 'hcl'
            }
            header?: never
            path: {
                /** @description Alert rule UID */
                UID: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description AlertingFileExport */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['AlertingFileExport']
                    'application/terraform+hcl': components['schemas']['AlertingFileExport']
                    'application/yaml': components['schemas']['AlertingFileExport']
                    'text/hcl': components['schemas']['AlertingFileExport']
                    'text/yaml': components['schemas']['AlertingFileExport']
                }
            }
            /** @description  Not found. */
            404: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
        }
    }
    RouteGetContactpoints: {
        parameters: {
            query?: {
                /** @description Filter by name */
                name?: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description ContactPoints */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ContactPoints']
                }
            }
        }
    }
    RoutePostContactpoints: {
        parameters: {
            query?: never
            header?: {
                'X-Disable-Provenance'?: string
            }
            path?: never
            cookie?: never
        }
        requestBody?: {
            content: {
                'application/json': components['schemas']['EmbeddedContactPoint']
            }
        }
        responses: {
            /** @description EmbeddedContactPoint */
            202: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['EmbeddedContactPoint']
                }
            }
            /** @description ValidationError */
            400: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ValidationError']
                }
            }
        }
    }
    RouteGetContactpointsExport: {
        parameters: {
            query?: {
                /** @description Whether to initiate a download of the file or not. */
                download?: boolean
                /** @description Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence. */
                format?: 'yaml' | 'json' | 'hcl'
                /** @description Whether any contained secure settings should be decrypted or left redacted. Redacted settings will contain RedactedValue instead. Currently, only org admin can view decrypted secure settings. */
                decrypt?: boolean
                /** @description Filter by name */
                name?: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description AlertingFileExport */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['AlertingFileExport']
                    'application/terraform+hcl': components['schemas']['AlertingFileExport']
                    'application/yaml': components['schemas']['AlertingFileExport']
                    'text/hcl': components['schemas']['AlertingFileExport']
                    'text/yaml': components['schemas']['AlertingFileExport']
                }
            }
            /** @description PermissionDenied */
            403: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['PermissionDenied']
                    'application/terraform+hcl': components['schemas']['PermissionDenied']
                    'application/yaml': components['schemas']['PermissionDenied']
                    'text/hcl': components['schemas']['PermissionDenied']
                    'text/yaml': components['schemas']['PermissionDenied']
                }
            }
        }
    }
    RoutePutContactpoint: {
        parameters: {
            query?: never
            header?: {
                'X-Disable-Provenance'?: string
            }
            path: {
                /** @description UID is the contact point unique identifier */
                UID: string
            }
            cookie?: never
        }
        requestBody?: {
            content: {
                'application/json': components['schemas']['EmbeddedContactPoint']
            }
        }
        responses: {
            /** @description Ack */
            202: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Ack']
                }
            }
            /** @description ValidationError */
            400: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ValidationError']
                }
            }
        }
    }
    RouteDeleteContactpoints: {
        parameters: {
            query?: never
            header?: never
            path: {
                /** @description UID is the contact point unique identifier */
                UID: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description  The contact point was deleted successfully. */
            202: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
        }
    }
    RouteGetAlertRuleGroup: {
        parameters: {
            query?: never
            header?: never
            path: {
                FolderUID: string
                Group: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description AlertRuleGroup */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['AlertRuleGroup']
                }
            }
            /** @description  Not found. */
            404: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
        }
    }
    RoutePutAlertRuleGroup: {
        parameters: {
            query?: never
            header?: {
                'X-Disable-Provenance'?: string
            }
            path: {
                FolderUID: string
                Group: string
            }
            cookie?: never
        }
        requestBody?: {
            content: {
                'application/json': components['schemas']['AlertRuleGroup']
            }
        }
        responses: {
            /** @description AlertRuleGroup */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['AlertRuleGroup']
                }
            }
            /** @description ValidationError */
            400: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ValidationError']
                }
            }
        }
    }
    RouteDeleteAlertRuleGroup: {
        parameters: {
            query?: never
            header?: never
            path: {
                FolderUID: string
                Group: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description  The alert rule group was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            /** @description ForbiddenError */
            403: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ForbiddenError']
                }
            }
            /** @description NotFound */
            404: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['NotFound']
                }
            }
        }
    }
    RouteGetAlertRuleGroupExport: {
        parameters: {
            query?: {
                /** @description Whether to initiate a download of the file or not. */
                download?: boolean
                /** @description Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence. */
                format?: 'yaml' | 'json' | 'hcl'
            }
            header?: never
            path: {
                FolderUID: string
                Group: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description AlertingFileExport */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['AlertingFileExport']
                    'application/terraform+hcl': components['schemas']['AlertingFileExport']
                    'application/yaml': components['schemas']['AlertingFileExport']
                    'text/hcl': components['schemas']['AlertingFileExport']
                    'text/yaml': components['schemas']['AlertingFileExport']
                }
            }
            /** @description  Not found. */
            404: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
        }
    }
    RouteGetMuteTimings: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description MuteTimings */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['MuteTimings']
                }
            }
        }
    }
    RoutePostMuteTiming: {
        parameters: {
            query?: never
            header?: {
                'X-Disable-Provenance'?: string
            }
            path?: never
            cookie?: never
        }
        requestBody?: {
            content: {
                'application/json': components['schemas']['MuteTimeInterval']
            }
        }
        responses: {
            /** @description MuteTimeInterval */
            201: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['MuteTimeInterval']
                }
            }
            /** @description ValidationError */
            400: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ValidationError']
                }
            }
        }
    }
    RouteExportMuteTimings: {
        parameters: {
            query?: {
                /** @description Whether to initiate a download of the file or not. */
                download?: boolean
                /** @description Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence. */
                format?: 'yaml' | 'json' | 'hcl'
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description AlertingFileExport */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['AlertingFileExport']
                    'application/terraform+hcl': components['schemas']['AlertingFileExport']
                    'application/yaml': components['schemas']['AlertingFileExport']
                    'text/hcl': components['schemas']['AlertingFileExport']
                    'text/yaml': components['schemas']['AlertingFileExport']
                }
            }
            /** @description PermissionDenied */
            403: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['PermissionDenied']
                    'application/terraform+hcl': components['schemas']['PermissionDenied']
                    'application/yaml': components['schemas']['PermissionDenied']
                    'text/hcl': components['schemas']['PermissionDenied']
                    'text/yaml': components['schemas']['PermissionDenied']
                }
            }
        }
    }
    RouteGetMuteTiming: {
        parameters: {
            query?: never
            header?: never
            path: {
                /** @description Mute timing name */
                name: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description MuteTimeInterval */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['MuteTimeInterval']
                }
            }
            /** @description  Not found. */
            404: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
        }
    }
    RoutePutMuteTiming: {
        parameters: {
            query?: never
            header?: {
                'X-Disable-Provenance'?: string
            }
            path: {
                /** @description Mute timing name */
                name: string
            }
            cookie?: never
        }
        requestBody?: {
            content: {
                'application/json': components['schemas']['MuteTimeInterval']
            }
        }
        responses: {
            /** @description MuteTimeInterval */
            202: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['MuteTimeInterval']
                }
            }
            /** @description ValidationError */
            400: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ValidationError']
                }
            }
            /** @description PublicError */
            409: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['PublicError']
                }
            }
        }
    }
    RouteDeleteMuteTiming: {
        parameters: {
            query?: {
                /** @description Version of mute timing to use for optimistic concurrency. Leave empty to disable validation */
                version?: string
            }
            header?: {
                'X-Disable-Provenance'?: string
            }
            path: {
                /** @description Mute timing name */
                name: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description  The mute timing was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            /** @description PublicError */
            409: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['PublicError']
                }
            }
        }
    }
    RouteExportMuteTiming: {
        parameters: {
            query?: {
                /** @description Whether to initiate a download of the file or not. */
                download?: boolean
                /** @description Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence. */
                format?: 'yaml' | 'json' | 'hcl'
            }
            header?: never
            path: {
                /** @description Mute timing name */
                name: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description AlertingFileExport */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['AlertingFileExport']
                    'application/terraform+hcl': components['schemas']['AlertingFileExport']
                    'application/yaml': components['schemas']['AlertingFileExport']
                    'text/hcl': components['schemas']['AlertingFileExport']
                    'text/yaml': components['schemas']['AlertingFileExport']
                }
            }
            /** @description PermissionDenied */
            403: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['PermissionDenied']
                    'application/terraform+hcl': components['schemas']['PermissionDenied']
                    'application/yaml': components['schemas']['PermissionDenied']
                    'text/hcl': components['schemas']['PermissionDenied']
                    'text/yaml': components['schemas']['PermissionDenied']
                }
            }
        }
    }
    RouteGetPolicyTree: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description Route */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Route']
                }
            }
        }
    }
    RoutePutPolicyTree: {
        parameters: {
            query?: never
            header?: {
                'X-Disable-Provenance'?: string
            }
            path?: never
            cookie?: never
        }
        /** @description The new notification routing tree to use */
        requestBody?: {
            content: {
                'application/json': components['schemas']['Route']
            }
        }
        responses: {
            /** @description Ack */
            202: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Ack']
                }
            }
            /** @description ValidationError */
            400: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ValidationError']
                }
            }
        }
    }
    RouteResetPolicyTree: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description Ack */
            202: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Ack']
                }
            }
        }
    }
    RouteGetPolicyTreeExport: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description AlertingFileExport */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['AlertingFileExport']
                    'application/terraform+hcl': components['schemas']['AlertingFileExport']
                    'application/yaml': components['schemas']['AlertingFileExport']
                    'text/hcl': components['schemas']['AlertingFileExport']
                    'text/yaml': components['schemas']['AlertingFileExport']
                }
            }
            /** @description NotFound */
            404: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['NotFound']
                    'application/terraform+hcl': components['schemas']['NotFound']
                    'application/yaml': components['schemas']['NotFound']
                    'text/hcl': components['schemas']['NotFound']
                    'text/yaml': components['schemas']['NotFound']
                }
            }
        }
    }
    RouteGetTemplates: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description NotificationTemplates */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['NotificationTemplates']
                }
            }
        }
    }
    RouteGetTemplate: {
        parameters: {
            query?: never
            header?: never
            path: {
                /** @description Template group name */
                name: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description NotificationTemplate */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['NotificationTemplate']
                }
            }
            /** @description PublicError */
            404: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['PublicError']
                }
            }
        }
    }
    RoutePutTemplate: {
        parameters: {
            query?: never
            header?: {
                'X-Disable-Provenance'?: string
            }
            path: {
                /** @description Template group name */
                name: string
            }
            cookie?: never
        }
        requestBody?: {
            content: {
                'application/json': components['schemas']['NotificationTemplateContent']
            }
        }
        responses: {
            /** @description NotificationTemplate */
            202: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['NotificationTemplate']
                }
            }
            /** @description PublicError */
            400: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['PublicError']
                }
            }
            /** @description PublicError */
            409: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['PublicError']
                }
            }
        }
    }
    RouteDeleteTemplate: {
        parameters: {
            query?: {
                /** @description Version of template to use for optimistic concurrency. Leave empty to disable validation */
                version?: string
            }
            header?: never
            path: {
                /** @description Template group name */
                name: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description  The template was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
            /** @description PublicError */
            409: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['PublicError']
                }
            }
        }
    }
    listAllProvidersSettings: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['listSSOSettingsResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
        }
    }
    getProviderSettings: {
        parameters: {
            query?: never
            header?: never
            path: {
                key: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            200: components['responses']['getSSOSettingsResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
        }
    }
    updateProviderSettings: {
        parameters: {
            query?: never
            header?: never
            path: {
                key: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': {
                    id: string
                    provider: string
                    settings: {
                        [key: string]: unknown
                    }
                }
            }
        }
        responses: {
            204: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            500: components['responses']['internalServerError']
        }
    }
    removeProviderSettings: {
        parameters: {
            query?: never
            header?: never
            path: {
                key: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            204: components['responses']['okResponse']
            400: components['responses']['badRequestError']
            401: components['responses']['unauthorisedError']
            403: components['responses']['forbiddenError']
            404: components['responses']['notFoundError']
            500: components['responses']['internalServerError']
        }
    }
}
